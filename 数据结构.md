# 408 数据结构笔记：线性结构篇

<!-- 提示：复制进去后，按 Ctrl+Shift+P 输入 TOC 更新目录 -->
- [408 数据结构笔记：线性结构篇](#408-数据结构笔记线性结构篇)
  - [第1章 线性表 (Linear List)](#第1章-线性表-linear-list)
    - [1.1 逻辑与存储结构](#11-逻辑与存储结构)
      - [顺序表 vs 链表 (选择题必考)](#顺序表-vs-链表-选择题必考)
    - [1.2 顺序表 (Sequence List)](#12-顺序表-sequence-list)
    - [1.3 单链表 (Single Linked List)](#13-单链表-single-linked-list)
    - [1.4 特殊链表 (考点速记)](#14-特殊链表-考点速记)
  - [第2章 栈与队列 (Stack \& Queue)](#第2章-栈与队列-stack--queue)
    - [2.1 核心特性](#21-核心特性)
    - [2.2 循环队列 (Circular Queue)](#22-循环队列-circular-queue)
    - [2.3 难点应用：表达式求值 (中缀转后缀)](#23-难点应用表达式求值-中缀转后缀)
      - [(1) 三种形式](#1-三种形式)
      - [(2) 手算技巧 (加括号法)](#2-手算技巧-加括号法)
      - [(3) 机算逻辑 (单调栈思想) —— 重点](#3-机算逻辑-单调栈思想--重点)
  - [第3章 数组与矩阵 (Arrays)](#第3章-数组与矩阵-arrays)
    - [3.1 数组地址计算](#31-数组地址计算)
    - [3.2 特殊矩阵压缩 (下标转换)](#32-特殊矩阵压缩-下标转换)
  - [第4章 串 (String) —— KMP 深度解析](#第4章-串-string--kmp-深度解析)
    - [4.1 基础概念：前缀与后缀](#41-基础概念前缀与后缀)
    - [4.2 KMP 核心：Next 数组](#42-kmp-核心next-数组)
      - [1. 物理含义 (为什么要算它？)](#1-物理含义-为什么要算它)
      - [2. 手算步骤 (408 必考)](#2-手算步骤-408-必考)
    - [4.3 KMP 进阶：Nextval 数组](#43-kmp-进阶nextval-数组)
      - [1. 为什么要优化？(HR 面试理论)](#1-为什么要优化hr-面试理论)
      - [2. 手算逻辑 (流程图)](#2-手算逻辑-流程图)
  - [第5章 树与二叉树 (Trees \& Binary Trees)](#第5章-树与二叉树-trees--binary-trees)
    - [5.1 核心术语 (避坑指南)](#51-核心术语-避坑指南)
    - [5.2 二叉树 (Binary Tree)](#52-二叉树-binary-tree)
      - [1. 两种特殊二叉树 (必考)](#1-两种特殊二叉树-必考)
      - [2. **上帝公式** (二叉树性质常考)](#2-上帝公式-二叉树性质常考)
      - [3. 完全二叉树的数组性质 (下标计算)](#3-完全二叉树的数组性质-下标计算)
    - [5.3 二叉树的存储结构](#53-二叉树的存储结构)
      - [(1) 顺序存储 (数组)](#1-顺序存储-数组)
      - [(2) 链式存储 (最常用)](#2-链式存储-最常用)
    - [🚀 408 速解技巧：完全二叉树求叶子数](#-408-速解技巧完全二叉树求叶子数)
    - [5.4 二叉树的遍历 (核心代码)](#54-二叉树的遍历-核心代码)
      - [1. 三种遍历的逻辑](#1-三种遍历的逻辑)
      - [2. 递归代码模板 (背诵全文)](#2-递归代码模板-背诵全文)
      - [3. 手算遍历结果 (画图法)](#3-手算遍历结果-画图法)
    - [5.5 层序遍历 (Level Order)](#55-层序遍历-level-order)
    - [5.6 递归算法的“万能套路” (大题必杀)](#56-递归算法的万能套路-大题必杀)
    - [5.7 线索二叉树 (Threaded Binary Tree)](#57-线索二叉树-threaded-binary-tree)
      - [1. 核心逻辑](#1-核心逻辑)
      - [2. 手绘线索 (考试必考)](#2-手绘线索-考试必考)
      - [3. 找后继的口诀 (难点)](#3-找后继的口诀-难点)
  - [第6章 树的应用 (三巨头)](#第6章-树的应用-三巨头)
    - [6.1 二叉排序树 (BST)](#61-二叉排序树-bst)
      - [1. 核心操作 (非递归查找常考)](#1-核心操作-非递归查找常考)
      - [2. 插入与构造](#2-插入与构造)
      - [3. 删除节点 (难点)](#3-删除节点-难点)
  - [不要移动节点指针！直接把替罪羊的值 (data) 复制给要删除的节点，然后把替罪羊那个节点删掉即可 (替罪羊一定没有左孩子，很好删)。](#不要移动节点指针直接把替罪羊的值-data-复制给要删除的节点然后把替罪羊那个节点删掉即可-替罪羊一定没有左孩子很好删)
    - [6.2 平衡二叉树 (AVL)](#62-平衡二叉树-avl)
      - [1. 背景与定义](#1-背景与定义)
      - [2. 四种失衡与旋转 (理解逻辑)](#2-四种失衡与旋转-理解逻辑)
    - [6.3 哈夫曼树 (Huffman Tree)](#63-哈夫曼树-huffman-tree)
      - [1. 什么是 WPL (带权路径长度)?](#1-什么是-wpl-带权路径长度)
      - [2. 哈夫曼树的定义](#2-哈夫曼树的定义)
      - [3. 构造过程 (哈夫曼编码基础)](#3-构造过程-哈夫曼编码基础)
    - [6.4 树、森林与并查集 (补全盲点)](#64-树森林与并查集-补全盲点)
      - [1. 树的存储结构](#1-树的存储结构)
      - [2. 树、森林与二叉树的转换 (必考手绘)](#2-树森林与二叉树的转换-必考手绘)
      - [3. 遍历的对应关系 (选择题陷阱)](#3-遍历的对应关系-选择题陷阱)
      - [4. 并查集 (Union-Find) —— 考点精简](#4-并查集-union-find--考点精简)
  - [第7章 图 (Graphs)](#第7章-图-graphs)
    - [7.1 图的存储结构 (必考)](#71-图的存储结构-必考)
      - [1. 邻接矩阵 (Adjacency Matrix)](#1-邻接矩阵-adjacency-matrix)
      - [2. 邻接表 (Adjacency List)](#2-邻接表-adjacency-list)
      - [3. 十字链表 \& 邻接多重表 (仅供了解)](#3-十字链表--邻接多重表-仅供了解)
    - [7.2 图的遍历 (Traversals)](#72-图的遍历-traversals)
      - [1. 广度优先搜索 (BFS) —— 类似树的层序遍历](#1-广度优先搜索-bfs--类似树的层序遍历)
      - [2. 深度优先搜索 (DFS) —— 类似树的先序遍历](#2-深度优先搜索-dfs--类似树的先序遍历)
  - [**DFS 不是走到死胡同就结束，而是走到死胡同就“回头”找新路，直到所有点都去过。**](#dfs-不是走到死胡同就结束而是走到死胡同就回头找新路直到所有点都去过)
    - [7.3 考点对比 (选择题高频)](#73-考点对比-选择题高频)
    - [7.4 最小生成树 (MST)](#74-最小生成树-mst)
      - [1. Prim 算法 (普里姆) —— “抓壮丁”](#1-prim-算法-普里姆--抓壮丁)
      - [2. Kruskal 算法 (克鲁斯卡尔) —— “并查集修路”](#2-kruskal-算法-克鲁斯卡尔--并查集修路)
    - [🧪 现场手推 (必考题型)](#-现场手推-必考题型)
      - [⚡️ 模拟 1：Kruskal 算法 (看全局的边)](#️-模拟-1kruskal-算法-看全局的边)
      - [⚡️ 模拟 2：Prim 算法 (从点 A 出发)](#️-模拟-2prim-算法-从点-a-出发)
    - [7.5 最短路径 (Dijkstra)](#75-最短路径-dijkstra)
      - [1. 算法定义](#1-算法定义)
      - [2. 三个核心数组 (做题工具)](#2-三个核心数组-做题工具)
      - [3. 核心逻辑 (贪心 + 松弛)](#3-核心逻辑-贪心--松弛)
      - [⚔️ 408 避坑指南：Prim vs Dijkstra](#️-408-避坑指南prim-vs-dijkstra)
      - [🧪 现场模拟 (手推填表)](#-现场模拟-手推填表)
        - [第一轮 (初始化)](#第一轮-初始化)
        - [第二轮 (选最小)](#第二轮-选最小)
        - [第三轮 (再选最小)](#第三轮-再选最小)
        - [第四轮](#第四轮)
    - [7.6 多源最短路径 (Floyd 算法)](#76-多源最短路径-floyd-算法)
      - [1. 核心思想](#1-核心思想)
      - [2. 手推过程 (填矩阵 - 必考)](#2-手推过程-填矩阵---必考)
      - [3. 408 做题技巧 (不要傻算)](#3-408-做题技巧-不要傻算)
      - [🧪 现场模拟 (Floyd 观察法)](#-现场模拟-floyd-观察法)
    - [7.7 有向无环图的应用 (DAG)](#77-有向无环图的应用-dag)
      - [1. 拓扑排序 (Topological Sort) - AOV 网](#1-拓扑排序-topological-sort---aov-网)
      - [2. 关键路径 (Critical Path) - AOE 网](#2-关键路径-critical-path---aoe-网)
  - [第8章 查找 (Searching)](#第8章-查找-searching)
    - [8.1 线性表的查找](#81-线性表的查找)
      - [1. 顺序查找 (Sequential Search)](#1-顺序查找-sequential-search)
      - [2. 折半查找 / 二分查找 (Binary Search) —— 必背](#2-折半查找--二分查找-binary-search--必背)
      - [3. 分块查找 (索引顺序查找)](#3-分块查找-索引顺序查找)
    - [8.2 B 树与 B+ 树 (大魔王)](#82-b-树与-b-树-大魔王)
      - [1. B 树 (m 阶) —— “多路胖胖树”](#1-b-树-m-阶--多路胖胖树)
      - [2. B+ 树 (数据库御用)](#2-b-树-数据库御用)
    - [8.3 散列 (Hash Tables)](#83-散列-hash-tables)
      - [1. 处理冲突的方法](#1-处理冲突的方法)
      - [2. 考点：ASL 计算 (查找长度)](#2-考点asl-计算-查找长度)

---

## 第1章 线性表 (Linear List)

### 1.1 逻辑与存储结构
> **核心考点**：区分逻辑结构和物理结构。
*   **逻辑结构**：**线性**的（一对一，像排队）。
*   **物理结构**：
    1.  **顺序存储（顺序表）**：数组实现，地址连续。
    2.  **链式存储（链表）**：指针实现，地址不连续。

#### 顺序表 vs 链表 (选择题必考)
| 维度 | 顺序表 (Array) | 链表 (LinkedList) | 场景选择 |
| :--- | :--- | :--- | :--- |
| **随机访问** | **支持** $O(1)$ | 不支持 $O(n)$ | 频繁按下标读取时选 |
| **插入/删除** | 慢 $O(n)$ (需搬家) | **快** $O(1)$ (改指针) | 频繁增删时选 |
| **空间分配** | 容易浪费或溢出 | 动态按需申请 | 长度变化大时选 |

### 1.2 顺序表 (Sequence List)
*   **结构定义**：
    ```cpp
    #define MaxSize 50
    typedef struct {
        int data[MaxSize];
        int length;
    } SqList;
    ```
*   **地址计算**：$LOC(a_i) = LOC(a_1) + (i-1) \times L$

### 1.3 单链表 (Single Linked List)
*   **结构定义 (背诵)**：
    ```cpp
    typedef struct LNode {
        int data;
        struct LNode *next;
    } LNode, *LinkList;
    ```
*   **头结点 (Head Node) 的作用**：
    1.  统一第一个位置的操作（不用单独写 if）。
    2.  统一空表和非空表的处理。
*   **核心操作：p 后插 s (先连后断)**：
    ```cpp
    s->next = p->next; // 1. 新人连下家
    p->next = s;       // 2. 老人连新人
    ```

### 1.4 特殊链表 (考点速记)
1.  **双链表**：
    *   有 `prior` 和 `next`。
    *   **插入顺序 (4步)**：先搞定新节点 s 的两只手，再改 p 和 p->next 的手。
2.  **循环链表**：
    *   **判空**：`L->next == L`
    *   **高频考点**：若需频繁操作**表头和表尾**，使用**带尾指针 (Rear)** 的循环链表，时间复杂度均为 $O(1)$。

---

## 第2章 栈与队列 (Stack & Queue)

### 2.1 核心特性
| 结构 | 特性 | 408 核心应用 |
| :--- | :--- | :--- |
| **栈** | **LIFO** (后进先出) | 递归、括号匹配、**表达式求值**、DFS |
| **队列** | **FIFO** (先进先出) | 缓冲区、层序遍历、BFS |

### 2.2 循环队列 (Circular Queue)
*   **核心思想**：牺牲一个存储单元，解决假溢出。
*   **入队**：`rear = (rear + 1) % MaxSize`
*   **判空**：`front == rear`
*   **判满**：`(rear + 1) % MaxSize == front`
*   **长度**：`(rear - front + MaxSize) % MaxSize`

### 2.3 难点应用：表达式求值 (中缀转后缀)
#### (1) 三种形式
*   中缀：`A + B`
*   后缀 (逆波兰)：`A B +` (计算机执行版)

#### (2) 手算技巧 (加括号法)
1.  按优先级把所有运算加括号。
2.  把符号移到对应的右括号后面。
3.  去掉所有括号。

#### (3) 机算逻辑 (单调栈思想) —— 重点
**规则：**
1.  **数字**：直接**输出**。
2.  **左括号 `(`**：直接**入栈**。
3.  **右括号 `)`**：**清场**。将栈顶直到 `(` 之间的所有符号弹出并输出。
4.  **运算符 (如 +)**：**踢馆**。
    *   如果栈顶符号优先级 **>=** 我：栈顶先弹出输出（强者先算）。
    *   重复直到栈顶比我弱或栈空：我**入栈**。

---

## 第3章 数组与矩阵 (Arrays)

### 3.1 数组地址计算
*   **行优先**：$LOC = \text{基址} + (i \times \text{列数} + j) \times \text{Size}$
*   **列优先**：$LOC = \text{基址} + (j \times \text{行数} + i) \times \text{Size}$

### 3.2 特殊矩阵压缩 (下标转换)
> **技巧**：考试时画 3x3 矩阵代入验证，不要死背公式。

*   **对称矩阵 (存下三角)**：$k = \frac{i(i-1)}{2} + j - 1$ (假设下标从1开始，存入0开始的数组)
*   **三对角矩阵**：$k = 2i + j - 3$

---

## 第4章 串 (String) —— KMP 深度解析

### 4.1 基础概念：前缀与后缀
KMP 的核心在于“利用已匹配部分的信息”，这依赖于对前缀后缀的精准理解。
*   **前缀 (Prefix)**：包含第一个字符，但**不包含最后一个字符**的子串。
    *   *例*：`Harry` 的前缀：`H`, `Ha`, `Har`...
*   **后缀 (Suffix)**：包含最后一个字符，但**不包含第一个字符**的子串。
    *   *例*：`Harry` 的后缀：`y`, `ry`, `rry`...
*   **最长相等前后缀**：
    *   在字符串中找到最长的一段，既是前缀又是后缀。
    *   *例*：`A B A B A` -> 最长是 `A B A` (前) 和 `A B A` (后)，长度为 **3**。

### 4.2 KMP 核心：Next 数组
#### 1. 物理含义 (为什么要算它？)
`next[j] = k` 的含义是：当模式串的**第 `j` 位匹配失败**时，说明前 `j-1` 位是匹配成功的。利用这前 `j-1` 位的**最长相等前后缀**，将模式串**向右滑动**，让第 `k` 位对齐当前主串的位置。

> **形象理解**：**“尺子滑动”**
> 既然“前缀(头)”和“后缀(尾)”长得一样，且“尾”刚才已经匹配过了，那就直接把“头”拖过来，盖在刚才“尾”的位置上，不用重新比了。

#### 2. 手算步骤 (408 必考)
**公式**：`next[j]` = 第 `j` 个字符**前面**子串的**最长相等前后缀长度 + 1**。
*   **规定**：`next[1] = 0`, `next[2] = 1`。

**实战演练**：模式串 `A B A B A`
| j | 当前字符 | **看它前面的子串** | 最长相等前后缀 | 长度 L | **Next[j] = L+1** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | A | (无) | - | - | **0** |
| 2 | B | `A` | 无 | 0 | **1** |
| 3 | A | `A B` | 前`A` 后`B` (不等) | 0 | **1** |
| 4 | B | `A B A` | 前`A` 后`A` (相等) | 1 | **2** |
| 5 | A | `A B A B` | 前`AB` 后`AB` (相等) | 2 | **3** |

### 4.3 KMP 进阶：Nextval 数组
#### 1. 为什么要优化？(HR 面试理论)
*   **Bug**：如果 `S[j]` 匹配失败，`next` 让我跳到 `S[k]`。但如果 **`S[j] == S[k]`** (替补和我长得一样)，那 `S[j]` 失败了，`S[k]` 上去肯定也失败。这是无效尝试。
*   **Fix**：如果是这种情况，直接**跳过**这个替补，去用替补的替补。

#### 2. 手算逻辑 (流程图)
先算出 `next` 数组，然后对于每个 `j`：
1.  看看 **我 (`S[j]`)** 和 **我要跳到的替补 (`S[next[j]]`)** 是不是长得一样？
2.  **如果一样 (S[j] == S[next[j]])**：
    *   说明替补也是废柴。
    *   **`nextval[j] = nextval[next[j]]`** (直接抄袭替补的 nextval，一步到位)。
3.  **如果不一样**：
    *   说明替补有点用，让他上。
    *   **`nextval[j] = next[j]`** (保持原样)。
4.  *注：`nextval[1]` 永远是 0。*

**实战演练**：模式串 `A A A B` (Next: 0 1 2 3)
*   `j=2` (A): 替补是 1号(A)。一样！-> `nextval[2] = nextval[1] = 0`。
*   `j=3` (A): 替补是 2号(A)。一样！-> `nextval[3] = nextval[2] = 0`。
*   `j=4` (B): 替补是 3号(A)。不一样！-> `nextval[4] = next[4] = 3`。
*   结果：`0 0 0 3`。

---


## 第5章 树与二叉树 (Trees & Binary Trees)

### 5.1 核心术语 (避坑指南)
*   **度 (Degree)**：
    *   **节点的度**：它有几个孩子 (分支数)。
    *   **树的度**：树里所有节点中，度**最大**的那个数值。
*   **高度/深度**：
    *   **深度**：从上往下数 (根是第1层)。
    *   **高度**：从下往上数 (叶子是第1层)。
    *   *注：408 通常默认根节点是第 1 层。*
*   **路径长度**：
    *   从节点 A 到 B 经过的**边**的条数 (不是节点数)。

### 5.2 二叉树 (Binary Tree)
> **定义**：每个节点最多 2 个孩子，且**分左右** (有序树)。

#### 1. 两种特殊二叉树 (必考)
| 类型 | 特征 | 存储优势 |
| :--- | :--- | :--- |
| **满二叉树** (Full BT) | **完美金字塔**。高度 $h$，节点数 $2^h - 1$。只有度为0和2的节点。 | 每一层都填满了。 |
| **完全二叉树** (Complete BT) | **金字塔缺右下角**。只有最后一层没满，且叶子全靠左。 | **适合数组存储** (不会有空洞浪费空间)。 |

#### 2. **上帝公式** (二叉树性质常考)
对于任何二叉树，设 $n_0$ 为叶子数，$n_2$ 为度为 2 的节点。
*   **公式**：$n_0 = n_2 + 1$
*   **通俗理解**：**叶子节点**永远比**分叉节点 (度2)** 多一个。
    *   *推导*：总边数 = $n-1$ = $2n_2 + n_1$。联立求解即得。

#### 3. 完全二叉树的数组性质 (下标计算)
如果把完全二叉树存进数组 (下标从 1 开始)：
*   **找孩子**：父节点 $i$ 的左孩子是 $2i$，右孩子是 $2i+1$。
*   **找爸爸**：节点 $i$ 的父节点 is $\lfloor i/2 \rfloor$。
*   **找分界线**：
    *   如果 $i > \lfloor n/2 \rfloor$，则 $i$ 也就是**叶子节点** (没有孩子)。
    *   此性质常用于**堆 (Heap)** 的调整。

### 5.3 二叉树的存储结构
#### (1) 顺序存储 (数组)
*   只适合**完全二叉树**。一般二叉树存进去会浪费大量 `0` 空间。

#### (2) 链式存储 (最常用)
```cpp
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;
```

### 🚀 408 速解技巧：完全二叉树求叶子数

请把这个**推导过程**写在笔记的 `5.2` 节下面，这是针对**完全二叉树 (CBT)** 的特效药。

**原理推导**：
1.  我们知道总节点 $n = n_0 + n_1 + n_2$。
2.  根据上帝公式 $n_2 = n_0 - 1$，带入上式。
3.  得到：$n = n_0 + n_1 + (n_0 - 1) = 2n_0 + n_1 - 1$。
4.  移项整理：**$2n_0 = n + 1 - n_1$**。

**关键点**：
在**完全二叉树**中，$n_1$（只有一个孩子的节点）**要么是 0，要么是 1**。（不可能超过 1 个，否则就不是紧凑排列了）。

**结论（口诀）**：
*   看 **$n$ 是奇数还是偶数**？
*   因为 $2n_0$ 肯定是偶数。
    *   如果 $n$ 是 **奇数** $\rightarrow$ $n_1 = 0$ $\rightarrow$ $n_0 = (n+1)/2$
    *   如果 $n$ 是 **偶数** $\rightarrow$ $n_1 = 1$ $\rightarrow$ $n_0 = n/2$

**🔥 秒杀刚才的题**：
*   题目：$n = 1001$。
*   判断：1001 是**奇数**。
*   秒杀：$n_1 = 0$，所以 $n_0 = (1001 + 1) / 2 = \mathbf{501}$。

*(对比一下你刚才算的 556，是不是这个方法又快又稳？)*

---

### 5.4 二叉树的遍历 (核心代码)

#### 1. 三种遍历的逻辑
这里的“先、中、后”指的是**根节点 (Root)** 什么时候被访问。
*   **先序 (PreOrder)**：**根** -> 左 -> 右
*   **中序 (InOrder)**：左 -> **根** -> 右
*   **后序 (PostOrder)**：左 -> 右 -> **根**

#### 2. 递归代码模板 (背诵全文)
这是所有树形算法的**母题**，必须能默写。

```cpp
// 二叉树节点定义
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 先序遍历
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T);            // 1. 访问根 (干活的地方)
        PreOrder(T->lchild); // 2. 递归左
        PreOrder(T->rchild); // 3. 递归右
    }
}

// 中序遍历：把 visit(T) 放到中间
// 后序遍历：把 visit(T) 放到最后
```

#### 3. 手算遍历结果 (画图法)
考试时给你一棵树图，让你写序列，千万别凭脑子空想，容易晕。
**方法：画轮廓线 (围墙法)**
1.  拿笔从根节点左边开始，沿着树的轮廓**画一圈**，紧贴着树，最后回到根节点。
2.  **先序**：第一次路过节点时，记录它。
3.  **中序**：第二次路过节点 (从左边回来，要去右边时) 记录它。
4.  **后序**：第三次路过节点 (从右边回来，要往上回溯时) 记录它。

---

### 5.5 层序遍历 (Level Order)
> **核心思想**：一层一层切，从左往右扫。
> **数据结构**：必须使用 **辅助队列 (Queue)**。

**代码模板 (手写题常考)**：
```cpp
void LevelOrder(BiTree T) {
    if (T == NULL) return;
    
    InitQueue(Q);       // 1. 初始化队列
    EnQueue(Q, T);      // 2. 根节点入队
    
    BiTree p;
    while (!IsEmpty(Q)) {      // 3. 队列不空就一直循环
        DeQueue(Q, p);         // 4. 出队一个
        visit(p);              // 5. 访问它
        
        // 6. 有左孩子带左孩子入队
        if (p->lchild != NULL) EnQueue(Q, p->lchild);
        // 7. 有右孩子带右孩子入队
        if (p->rchild != NULL) EnQueue(Q, p->rchild);
    }
}
```

---

### 5.6 递归算法的“万能套路” (大题必杀)
408 大题很少直接让你写“遍历”，而是让你“求树高”、“求节点数”、“翻转二叉树”。
**核心心法**：**分治法 (Divide and Conquer)**。
1.  **问左边**：喂，左子树，你有多高？
2.  **问右边**：喂，右子树，你有多高？
3.  **算自己**：我的高度 = Max(左，右) + 1。

**求树深度的代码 (背诵)**：
```cpp
int Depth(BiTree T) {
    if (T == NULL) return 0; // 递归出口：空树高度为0
    
    int l_dep = Depth(T->lchild); // 左子树高度
    int r_dep = Depth(T->rchild); // 右子树高度
    
    // 返回较大者 + 1
    return (l_dep > r_dep ? l_dep : r_dep) + 1;
}
```
> **思考**：这其实是**后序遍历**的变种（左右根）。因为必须先知道孩子的情况，才能汇总算出爸爸的情况。
求书中节点的值比k大的节点的个数
```cpp
int CountK(BiTree T, int k) {
    // 1. 递归出口 (空树)
    if (T == NULL) return 0; 

    // 2. 问左子树 (递归)
    int left_sum = CountK(T->lchild, k); 

    // 3. 问右子树 (递归)
    int right_sum = CountK(T->rchild, k); 

    // 4. 看看自己 (当前节点)
    int my_val = 0;
    if (T->data > k) {  // 题目要求 大于 k
        my_val = 1;
    }

    // 5. 汇总返回
    return left_sum + right_sum + my_val;
}
```
---

### 5.7 线索二叉树 (Threaded Binary Tree)
#### 1. 核心逻辑
*   **背景**：$n$ 个节点的二叉树有 $n+1$ 个空指针。
*   **定义**：利用空指针指向**前驱** (左空) 或 **后继** (右空)。
*   **标志位**：`ltag/rtag`。`0` 表示指孩子，`1` 表示指线索。

#### 2. 手绘线索 (考试必考)
**步骤**：
1.  写出**中序遍历序列**。
2.  **左空连前驱，右空连后继**。
    *   (第一个节点的左指针和最后一个节点的右指针挂空)。

#### 3. 找后继的口诀 (难点)
*   **红灯 (rtag==1)**：直接走，指谁就是谁。
*   **绿灯 (rtag==0)**：有右孩子。后继是**右子树里最左下**的那个节点。
---
## 第6章 树的应用 (三巨头)

### 6.1 二叉排序树 (BST)
> **定义**：**左 < 根 < 右** (对于任意节点都成立)。
> **核心性质**：BST 的**中序遍历**序列是一个**递增序列** (考题突破口)。

#### 1. 核心操作 (非递归查找常考)
*   **查找效率**：
    *   最好情况：$O(\log n)$ (树是胖胖的)。
    *   最坏情况：$O(n)$ (树退化成链表，像糖葫芦一样)。
*   **代码逻辑**：
    ```cpp
    // 查找 val
    while (T != NULL && T->data != val) {
        if (val < T->data) T = T->lchild; // 小就在左边找
        else T = T->rchild;               // 大就在右边找
    }
    return T;
    ```

#### 2. 插入与构造
*   **规则**：新来的总是当**叶子**。
    *   比当前节点小 -> 往左走。
    *   比当前节点大 -> 往右走。
    *   走到空位 -> 坐下 (malloc)。

#### 3. 删除节点 (难点)
如果要删除节点 `z`，分三种情况：
1.  `z` 是叶子：直接删。
2.  `z` 只有一条腿 (左子树或右子树)：子承父业，让孩子顶替 `z` 的位置。
3.  `z` **儿女双全** (最常考)：
    *   **方法**：在 `z` 的**中序前驱** (左子树最右下) 或 **中序后继** (右子树最左下) 中找一个替死鬼 `p`。
    *   **操作**：把 `p` 的值填到 `z` 里，然后把原来的 `p` 删掉 (转为情况 1 或 2)。
找替罪羊的方法 (儿女双全时)：
找中序前驱：去左子树，然后一直往右走到底。
找中序后继：去右子树，然后一直往左走到底。
操作技巧：
不要移动节点指针！直接把替罪羊的值 (data) 复制给要删除的节点，然后把替罪羊那个节点删掉即可 (替罪羊一定没有左孩子，很好删)。
---

### 6.2 平衡二叉树 (AVL)

#### 1. 背景与定义
*   **目的**：防止二叉排序树退化成链表，保证查找效率稳定在 $O(\log n)$。
*   **定义**：任意节点的**左右子树高度差绝对值不超过 1**。
*   **平衡因子 (BF)**：$BF = H_{左} - H_{右}$。值只能是 -1, 0, 1。

#### 2. 四种失衡与旋转 (理解逻辑)
当插入节点导致某节点 A 失衡 ($|BF|=2$) 时，看**“麻烦”出在哪**：

| 类型 | 麻烦位置 | 形象描述 | 旋转方案 | 谁上位(新根)? |
| :--- | :--- | :--- | :--- | :--- |
| **LL 型** | A 的**左**孩子的**左**边 | 向左撇的直线 `/` | **右单旋** (提住中间，顺时针转) | 儿子 (B) |
| **RR 型** | A 的**右**孩子的**右**边 | 向右撇的直线 `\` | **左单旋** (提住中间，逆时针转) | 儿子 (B) |
| **LR 型** | A 的**左**孩子的**右**边 | 拐弯的小于号 `<` | **先左旋，后右旋** | 孙子 (C) |
| **RL 型** | A 的**右**孩子的**左**边 | 拐弯的大于号 `>` | **先右旋，后左旋** | 孙子 (C) |

> **核心记忆**：
> *   **直的 (LL, RR)**：转一次。中间那个节点上位。
> *   **弯的 (LR, RL)**：转两次。最下面那个“尖尖上”的节点 (孙子) 最终上位。
---

### 6.3 哈夫曼树 (Huffman Tree)

#### 1. 什么是 WPL (带权路径长度)?
*   **路径长度 (Length)**：从根节点到该节点经过的**边数** (层数 - 1)。
*   **权 (Weight)**：节点代表的数值 (频率/重要性)。
*   **WPL 计算公式**：
    $$ WPL = \sum_{\text{所有叶子}} (\text{叶子权值} \times \text{它到根的距离}) $$
*   **通俗理解**：搬运工的体力消耗。重物 (权大) 要放得近 (路径短)，轻物 (权小) 可以放得远。

#### 2. 哈夫曼树的定义
*   **定义**：在所有含 $n$ 个带权叶子节点的二叉树中，**WPL 最小**的那棵树 (也叫最优二叉树)。
*   **特征**：
    *   **权值越大，离根越近**。
    *   只有度为 0 (叶子) 和度为 2 的节点，**没有度为 1 的节点**。

#### 3. 构造过程 (哈夫曼编码基础)
1.  **选小**：在森林中选出两个**根节点权值最小**的树。
2.  **组队**：让它们做一个新节点的左右孩子，新节点权值 = 左+右。
3.  **归队**：把新节点放回森林，老节点踢出。
4.  **重复**：直到只剩一棵树。

### 6.4 树、森林与并查集 (补全盲点)

#### 1. 树的存储结构
普通树（一个节点可以有 N 个孩子）怎么存？
*   **双亲表示法**：用数组存。每个节点记下 `data` 和 `parent` (爸爸的下标)。
    *   *优点*：找爸爸 $O(1)$。*缺点*：找孩子难。
*   **孩子表示法**：用数组+链表（像邻接表的拉链法）。
*   **孩子兄弟表示法 (最重要)**：
    *   **核心法则**：**左孩子右兄弟 (Left-Child, Right-Sibling)**。
    *   **物理结构**：其实就是二叉链表！
        *   `lchild` 指向：**第一个孩子**。
        *   `rchild` 指向：**下一个亲兄弟**。
    *   *考点*：通过这个规则，任何“普通树”都能转换成唯一的一棵“二叉树”。

#### 2. 树、森林与二叉树的转换 (必考手绘)
*   **树 -> 二叉树**：
    1.  **加线**：所有亲兄弟之间连线。
    2.  **抹线**：只保留和**长子**的连线，断开和其他孩子的连线。
    3.  **旋转**：顺时针转 45 度。
*   **森林 -> 二叉树**：
    *   把森林里的每一棵树都变成二叉树。
    *   把第 2 棵树当作第 1 棵树的“右兄弟”连上去，以此类推。

#### 3. 遍历的对应关系 (选择题陷阱)
这是 408 最爱考的“张冠李戴”题。

| 结构 | 遍历方式 | 对应二叉树的遍历 |
| :--- | :--- | :--- |
| **树 (Tree)** | 先根遍历 (PreOrder) | = 二叉树的 **先序** |
| | **后根遍历 (PostOrder)** | = 二叉树的 **中序** (注意! 不是后序) |
| **森林 (Forest)** | 先序遍历 | = 二叉树的 **先序** |
| | **中序遍历** | = 二叉树的 **中序** |

> **记忆口诀**：
> *   普通树没有“中序”，只有先根和后根。
> *   **树的后根** 对应 **二叉树的中序** (因为“右兄弟”代表剩下的部分，后根是最后才访问剩下的)。
> *   **森林的中序** 对应 **二叉树的中序**。

#### 4. 并查集 (Union-Find) —— 考点精简
用于处理“集合合并”和“查关系”的数据结构（数组实现）。
*   **结构**：`S[]` 数组。`S[i]` 存的是父亲的下标。如果 `S[i] < 0`，说明 `i` 是根。
*   **核心操作**：
    1.  **Find(x)**：找 x 的老大（根）。
    2.  **Union(x, y)**：把 x 的老大 和 y 的老大 连起来（让其中一个当另一个的儿子）。
*   **优化 (考代码填空)**：
    *   **路径压缩**：找老大时，把沿途路过的所有人都**直接挂在老大下面**。下次再找就是 $O(1)$。


## 第7章 图 (Graphs)

### 7.1 图的存储结构 (必考)
图的核心难题是：**多对多**，怎么存进计算机？

#### 1. 邻接矩阵 (Adjacency Matrix)
*   **结构**：二维数组 `A[n][n]`。
*   **规则**：
    *   `A[i][j] = 1` (或权值)：表示节点 i 到 j **有边**。
    *   `A[i][j] = 0` (或 $\infty$)：表示**无边**。
*   **特点**：
    *   **空间复杂度**：$O(n^2)$。只和顶点数有关，跟边数无关。
    *   **适合**：**稠密图** (边很多)。
    *   **算度数**：
        *   无向图：第 i 行之和 = 顶点 i 的度。
        *   有向图：行和 = 出度；列和 = 入度。

#### 2. 邻接表 (Adjacency List)
*   **结构**：**数组 + 链表** (像哈希表的拉链法)。
    *   `VNode` (顶点表)：存数据 + 指向第一条边的指针。
    *   `ArcNode` (边表)：存邻接点下标 + 指向下一条边的指针。
*   **特点**：
    *   **空间复杂度**：
        *   无向图：$O(|V| + 2|E|)$ (每条边存了两次)。
        *   有向图：$O(|V| + |E|)$。
    *   **适合**：**稀疏图** (边很少)。
    *   **注意**：邻接表的表示**不唯一** (取决于链表里节点的链接顺序)，但邻接矩阵是唯一的。

#### 3. 十字链表 & 邻接多重表 (仅供了解)
*   **十字链表**：专门存**有向图** (解决邻接表找入度难的问题)。
*   **邻接多重表**：专门存**无向图** (解决邻接表删除边麻烦的问题)。

---

### 7.2 图的遍历 (Traversals)
图的遍历必须记录 `visited[]` 数组，防止转圈死循环。

#### 1. 广度优先搜索 (BFS) —— 类似树的层序遍历
*   **数据结构**：**队列 (Queue)**。
*   **过程**：
    1.  访问初始点 v，入队。
    2.  队头 u 出队。
    3.  **一次性**把 u 的**所有未访问过的邻居** w1, w2... 放入队列。
    4.  重复直到队空。
*   **应用**：
    *   **最短路径** (仅限无权图)：BFS 第一次访问到某点时，经过的路径一定是最短的。
    *   **BFS 生成树**：遍历过程形成的树。

#### 2. 深度优先搜索 (DFS) —— 类似树的先序遍历
*   **数据结构**：**栈 (Stack)** (常通过递归实现)。
*   **过程**：
    1.  访问 v。
    2.  找 v 的**第一个**邻居 w。
    3.  如果 w 没访问过，**一条路走到黑** (递归调用 DFS(w))。
    4.  如果 w 访问过了，回退找 v 的**下一个**邻居。
   **DFS 不是走到死胡同就结束，而是走到死胡同就“回头”找新路，直到所有点都去过。**
---

### 7.3 考点对比 (选择题高频)
| 维度 | 邻接矩阵 | 邻接表 |
| :--- | :--- | :--- |
| **空间** | $O(n^2)$ 固定 | $O(V+E)$ 动态 |
| **判断两点有边** | $O(1)$ 极快 | $O(度)$ 慢 |
| **找所有邻居** | $O(n)$ 慢 (要扫描一行) | $O(度)$ 快 |
| **唯一性** | 唯一 | 不唯一 |


### 7.4 最小生成树 (MST)

---

#### 1. Prim 算法 (普里姆) —— “抓壮丁”

*   **适合场景**：**稠密图** (边多)。
*   **核心逻辑**：
    1.  **建群**：随便选一个点（比如 A）作为“已选集合”。
    2.  **诱惑**：看所有**连接“已选集合”与“未选集合”的边**。
    3.  **抓人**：选一条**最短**的边，把对面的那个点抓进群。
    4.  **重复**：直到所有人都进群。

> **记忆口诀**：**Prim 是“点找点”，谁离我最近，我就把谁拉入伙。**

#### 2. Kruskal 算法 (克鲁斯卡尔) —— “并查集修路”

*   **适合场景**：**稀疏图** (边少)。
*   **核心逻辑**：
    1.  **排序**：把所有的边按权值**从小到大**扔在一个列表里。
    2.  **选边**：拿出最小的一条边。
    3.  **判圈 (并查集核心)**：
        *   这两个点是不是**已经连通**了（是不是同一个老大）？
        *   **是**：跳过（否则会形成回路/环）。
        *   **否**：选中这条边，**Union** 这两个帮派。
    4.  **重复**：直到选够 $n-1$ 条边。

> **记忆口诀**：**Kruskal 是“边找边”，先修最便宜的路，只要不转圈就行。**

---

### 🧪 现场手推 (必考题型)

为了让你一次性记住这两个的区别，我们用同一个图来模拟。

**图结构 (无向带权图)**：
*   顶点：A, B, C, D
*   边权：
    *   (A, B) = 1
    *   (B, C) = 4
    *   (C, D) = 2
    *   (A, C) = 10
    *   (B, D) = 5

---

#### ⚡️ 模拟 1：Kruskal 算法 (看全局的边)
1.  **列出所有边并排序**：
    *   (A, B) = 1
    *   (C, D) = 2
    *   (B, C) = 4
    *   (B, D) = 5
    *   (A, C) = 10
2.  **第一步**：选最小 **(A, B) = 1**。连上。
3.  **第二步**：选次小 **(C, D) = 2**。连上。
4.  **第三步**：选第三小 **(B, C) = 4**。
    *   检查：B 和 C 连通了吗？目前没有（A-B 一伙，C-D 一伙）。
    *   **连上！** (现在大家都连通了)。
5.  **结束**：选够 3 条边了。总花费 = 1+2+4 = 7。

---

#### ⚡️ 模拟 2：Prim 算法 (从点 A 出发)
1.  **初始**：已选集合 `{A}`。
2.  **第一轮**：
    *   A 能连出去的边：(A,B)=1, (A,C)=10。
    *   选最小：**(A, B) = 1**。
    *   **B 入伙**。集合 `{A, B}`。
3.  **第二轮**：
    *   A 或 B 能连出去（且连向外面）的边：(A,C)=10, (B,C)=4, (B,D)=5。
    *   选最小：**(B, C) = 4**。
    *   **C 入伙**。集合 `{A, B, C}`。
4.  **第三轮**：
    *   A, B, C 能连出去的边：(A,C)无效(都在群里), (B,D)=5, (C,D)=2。
    *   选最小：**(C, D) = 2**。
    *   **D 入伙**。
5.  **结束**。总花费 = 1+4+2 = 7。

> **关于 MST 的唯一性 (选择题考点)**：
> 1.  **权值之和 (Cost)**：Prim 和 Kruskal 算出来的结果**一定相同** (都是最小值)。
> 2.  **树的形状 (Shape)**：
>     *   如果图中**所有边的权值都不相同**，则 MST 的形状**唯一**。
>     *   如果图中**有权值相同的边**，则 MST 的形状**可能不唯一** (有好几种连法，但总花费一样)。

### 7.5 最短路径 (Dijkstra)

#### 1. 算法定义
*   **功能**：计算**单源**最短路径 (从起点 $V_0$ 到其余所有顶点的最短距离)。
*   **限制**：**图中不能有负权值的边** (否则算法失效，得用 Floyd 或 Bellman-Ford)。
*   **时间复杂度**：$O(n^2)$ (和 Prim 一样)。

#### 2. 三个核心数组 (做题工具)
假设起点是 0 号节点：
1.  `final[i]` (标记数组)：记录节点 $i$ 是否已经找到了最短路径 (是否已“归位”)。
2.  **`dist[i]` (距离数组 - 核心)**：记录当前从起点 0 到节点 $i$ 的最短距离。
    *   初始时：自己到自己是 0，到邻居是边权，到不连通的是 $\infty$。
3.  `path[i]` (路径数组)：记录节点 $i$ 的前驱是谁 (为了复原路径)。

#### 3. 核心逻辑 (贪心 + 松弛)
1.  **选最小**：从 `dist` 数组里找一个**没归位** (`final`为false) 且 **数值最小** 的顶点 $u$。
2.  **归位**：标记 `final[u] = true` ($u$ 的最短路定死了，以后不动了)。
3.  **松弛 (Relax)**：以 $u$ 为跳板，看能不能优化别人的距离。
    *   **公式**：如果 `dist[u] + weight(u, v) < dist[v]`，
    *   **更新**：`dist[v] = dist[u] + weight(u, v)`。
    *   (通俗说：**我发现了一条经过 $u$ 到 $v$ 的路，比原来的路更近，赶紧更新！**)
4.  **循环**：重复 $n-1$ 次，直到所有点都归位。


---

#### ⚔️ 408 避坑指南：Prim vs Dijkstra

这两个算法的代码长得几乎一模一样，填表过程也很像，**极容易搞混**。
请务必把下面这个对比记在心里：

| 维度 | Prim (最小生成树) | Dijkstra (最短路径) |
| :--- | :--- | :--- |
| **dist数组存什么?** | 存节点到 **“已选集合”** 的距离 | 存节点到 **“起点 $V_0$”** 的**累加**距离 |
| **核心差异** | **不累加** (只看最后一条边) | **累加** (起点到我 + 我到你) |
| **目的** | 连通全图，总权值最小 | 找出起点的最短路 |

---

#### 🧪 现场模拟 (手推填表)

我们用一个简单的图来演示“累加”的过程。
**图结构**：
*   0 -> 1 (权值 10)
*   0 -> 2 (权值 5)
*   2 -> 1 (权值 3)   <-- 注意这条路
*   1 -> 3 (权值 1)
*   2 -> 3 (权值 9)

**起点：0**。

##### 第一轮 (初始化)
*   **归位**：{0}
*   **dist 状态**：
    *   `dist[1] = 10` (直接到)
    *   `dist[2] = 5` (直接到)
    *   `dist[3] = \infty` (到不了)

##### 第二轮 (选最小)
*   **选人**：在 10, 5, $\infty$ 里选最小 -> **选 2**。
*   **归位**：{0, 2}
*   **松弛 (借道 2)**：
    *   看看通过 2 能不能让别人更近？
    *   **看 1**：原来 0->1 是 10。现在 0->2->1 是 $5 + 3 = 8$。
        *   **8 < 10，更新！** `dist[1] = 8`。
    *   **看 3**：原来是 $\infty$。现在 0->2->3 是 $5 + 9 = 14$。
        *   更新！`dist[3] = 14`。
*   **当前 dist**：`[0, 8, 5, 14]` (注意 1 变成 8 了)。

##### 第三轮 (再选最小)
*   **选人**：剩下的没归位的有 1 (是8), 3 (是14)。**选 1**。
*   **归位**：{0, 2, 1}
*   **松弛 (借道 1)**：
    *   看看通过 1 能不能优化别人？
    *   **看 3**：原来 0->...->3 是 14 (0->2->3)。
    *   现在走新路：0->2->1->3。距离是 `dist[1] + 1` = $8 + 1 = 9$。
    *   **9 < 14，更新！** `dist[3] = 9`。
*   **当前 dist**：`[0, 8, 5, 9]`。

##### 第四轮
*   选 3，结束。

---

### 7.6 多源最短路径 (Floyd 算法)

#### 1. 核心思想
*   **目的**：求任意两点 $(i, j)$ 之间的最短距离。
*   **逻辑**：**暴力枚举中转点**。
    *   问：从 $i$ 直接到 $j$ 近？还是从 $i$ 经过 $k$ 再到 $j$ 近？
*   **公式**：$A[i][j] = \min(A[i][j], \ A[i][k] + A[k][j])$

#### 2. 手推过程 (填矩阵 - 必考)
我们维护两个矩阵：
*   **$A$ (距离矩阵)**：存最短距离 (初始化就是邻接矩阵，不通的是 $\infty$)。
*   **$Path$ (路径矩阵)**：存中转点 (初始化都是 -1)。

**迭代步骤**：
一共进行 $n$ 轮 (假设节点是 0, 1, 2)。
*   **第 0 轮**：允许以 **0号节点** 作为中转站。
    *   检查所有格子：$A[i][j]$ 是否大于 $A[i][0] + A[0][j]$？
    *   如果是，更新 $A[i][j]$。
*   **第 1 轮**：允许以 **0号、1号** 作为中转站。
    *   检查：$A[i][j]$ 是否大于 $A[i][1] + A[1][j]$？
*   **第 2 轮**：允许以 **0,1,2** 作为中转站。
    *   ...

#### 3. 408 做题技巧 (不要傻算)
考试如果让你画 Floyd 的矩阵变化，千万别写 3 重循环算几百次。
**观察法**：
1.  **画圈法**：
    *   如果要加入 **k号** 中转点。
    *   先把矩阵的 **第 k 行** 和 **第 k 列** 圈起来（这两行两列的数值在这一轮**永远不会变**）。
    *   还要把 **主对角线** (自己到自己) 圈起来（永远是 0）。
2.  **只看没圈的**：
    *   剩下的格子，每一个都用“十字交叉法”看一眼。
    *   比如看 $A[x][y]$，就看它对应的 **第 k 行那个数** 和 **第 k 列那个数** 加起来是不是比自己小。


---

#### 🧪 现场模拟 (Floyd 观察法)

我们用刚才 Dijkstra 那个图来试一下 Floyd 的第一轮。
**图**：
*   0 -> 1 (权值 10)
*   0 -> 2 (权值 5)
*   2 -> 1 (权值 3)   <-- 注意这条路
*   1 -> 3 (权值 1)
*   2 -> 3 (权值 9)

**初始矩阵 A0** (行是起点，列是终点)：
```text
      0   1   2   3
0 |   0  10   5  inf
1 | inf   0 inf   1
2 | inf   3   0   9
3 | inf inf inf   0
```

**现在进行“k=0”这一轮（允许经过 0 号点中转）**：

1.  **圈死**：第 0 行、第 0 列、对角线。这些不用看，照抄。
2.  **看剩下的**：
    *   比如看 **A[2][1]** (原本是 3)：
        *   看经过 0 中转：$A[2][0] (\infty) + A[0][1] (10) = \infty$。
        *   3 < $\infty$，**不更新**。
    *   比如看 **A[2][3]** (原本是 9)：
        *   看经过 0 中转：$A[2][0] (\infty) + A[0][3] (\infty) = \infty$。
        *   不更新。

**结论**：因为 2 号根本去不了 0 号 (单向边)，所以以 0 做中转没用。这一轮矩阵没变。

**假如进行“k=2”这一轮（允许经过 2 号点中转）。我们看 `A[0][1]` (原本是 10)：**
*   经过 2 中转：$A[0][2] (5) + A[2][1] (3) = 8$。
*   **8 < 10，更新！**
*   这就对应了 Dijkstra 算出来的那个结果。

### 7.7 有向无环图的应用 (DAG)

#### 1. 拓扑排序 (Topological Sort) - AOV 网
*   **定义**：做事情的先后顺序（必须先穿袜子再穿鞋）。
*   **手推步骤 (消消乐)**：
    1.  找一个**入度为 0** (没人指向我) 的顶点。
    2.  **输出**它，并**删除**它和它连出去的所有边。
    3.  重复，直到图空了。
*   **考点**：
    *   如果图还没空，但找不到入度为 0 的点了 -> 说明**有环** (死循环)。
    *   拓扑序列通常**不唯一**。
    *   **逆拓扑排序**：就是利用 DFS 的“回溯”顺序 (出栈顺序的逆序)。

#### 2. 关键路径 (Critical Path) - AOE 网
*   **定义**：完成整个工程**至少**需要多少时间（找到**最长**的那条路径）。
*   **四个核心参数 (填表必考)**：
    1.  **ve(k)** 事件最早开始：从源点开始，**往后推**，遇分叉取**大** (必须等所有前置任务做完)。
    2.  **vl(k)** 事件最迟开始：从终点开始，**往前推**，遇分叉取**小** (不能耽误后续工期)。
    3.  **e(i)** 活动最早：= 起点的 ve。
    4.  **l(i)** 活动最迟：= 终点的 vl - 活动持续时间。
*   **关键活动**：**l(i) == e(i)** 的活动（一点懒都不能偷的活动）。
*   **关键路径**：所有关键活动连成的线。


## 第8章 查找 (Searching)

### 8.1 线性表的查找
#### 1. 顺序查找 (Sequential Search)
*   **普通版**：`for` 循环从头比到尾。
*   **哨兵版 (Sentinel)**：
    *   **技巧**：把 `A[0]` 留空，把要查的值 `key` 放在 `A[0]`。
    *   **遍历**：从后往前找 (`i=n; while(A[i]!=key) i--;`)。
    *   **优势**：循环里**不需要判断越界** (因为 `A[0]` 一定相等，会自动停下)，每步省一次比较。

#### 2. 折半查找 / 二分查找 (Binary Search) —— 必背
*   **条件**：必须是**有序**的**顺序表** (链表不行！)。
*   **代码模板 (闭区间写法)**：
    ```cpp
    int BinarySearch(int A[], int n, int key) {
        int low = 0, high = n - 1, mid;
        while (low <= high) {            // 注意是 <=
            mid = (low + high) / 2;      // 只有顺序表支持除法下标
            if (A[mid] == key) return mid;
            else if (A[mid] > key) high = mid - 1; // 去左半边
            else low = mid + 1;                    // 去右半边
        }
        return -1; // 没找到
    }
    ```
*   **考点：判定树 (Decision Tree)**
    *   二分查找的过程，对应一棵**二叉排序树 (BST)**。
    *   **查找成功 ASL**：计算树种每一层节点个数 × 层数 / 总数。
    *   **查找失败 ASL**：看**空链域** (判定树的圆形叶子节点)。

#### 3. 分块查找 (索引顺序查找)
*   **思想**：块内无序，块间有序。
*   **效率**：介于顺序和二分之间。

---

### 8.2 B 树与 B+ 树 (大魔王)
这是为磁盘文件存储设计的多路平衡查找树。

#### 1. B 树 (m 阶) —— “多路胖胖树”
*   **定义 (5条铁律)**：
    1.  **根节点**：至少 **2** 个孩子 (除非整棵树就一个根)。
    2.  **非根节点**：至少 $\lceil m/2 \rceil$ 个孩子。
    3.  **关键字数 ($n$)**：`孩子数 - 1`。即 $[\lceil m/2 \rceil - 1, m-1]$。
    4.  **叶子节点**：所有的叶子都在**同一层** (绝对平衡)。
    5.  **查找**：类似 BST，但每个节点里有多个关键字，节点内用顺序查找，节点间用指针下钻。

*   **核心操作：分裂与合并 (必考手推)**
    *   **插入 (分裂)**：
        *   如果节点满了 (关键字 $> m-1$)。
        *     **中间的**关键字提拔上去当爸爸。
        *   剩下的两半变成两个孩子。
    *   **删除 (借位/合并)**：
        *   **不够借**：兄弟也没余粮 -> **合并** (把兄弟、爸爸中间那个、自己，三合一)。
        *   **够借**：兄弟有钱 -> **父子换位** (把兄弟最大的给爸爸，爸爸下来的给自己)。

#### 2. B+ 树 (数据库御用)
*   **与 B 树的区别 (死记)**：
    1.  **数据位置**：B+ 树的所有数据都存放在**叶子节点**。内部节点只是路标 (索引)。(B 树每个节点都存数据)。
    2.  **指针**：B+ 树的叶子节点连成一条**链表** (方便范围查询，如 `select * from table where id > 10`)。
    3.  **孩子个数**：B+ 树有 $n$ 个关键字就有 $n$ 个孩子。(B 树是 $n+1$ 个孩子)。

---

### 8.3 散列 (Hash Tables)
*   **核心**：`Addr = H(key)`。理想时间 $O(1)$。
*   **冲突 (Collision)**：不同 Key 算出了同一个 Addr。

#### 1. 处理冲突的方法
*   **开放定址法 (Open Addressing)**：
    *   **线性探测**：`+1, +2, +3...` (容易产生堆积)。
    *   **平方探测**：`+1^2, -1^2, +2^2, -2^2...` (跳着找，甚至能跑遍全表)。
*   **拉链法 (Chaining)**：
    *   冲突的都挂在链表里 (408 大题最爱考，算 ASL 最简单)。

#### 2. 考点：ASL 计算 (查找长度)
*   **装填因子 ($\alpha$)**：$\alpha = \frac{\text{表中元素个数}}{\text{表长}}$。$\alpha$ 越大，冲突概率越大。
*   **ASL 成功**：$\sum \text{每个元素被找到的比较次数} / \text{元素总数}$。
*   **ASL 失败**：$\sum \text{每个位置查到空所需的次数} / \text{模数 P}$ (注意分母是 P 不是表长！)。