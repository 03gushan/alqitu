# 408 算法代码特训 (Algorithm Templates)

> **使用说明**：
> 1.  所有代码基于 C/C++ 混合语法 (408 标准)。
> 2.  **重点背诵**：标有 `⭐⭐⭐` 的核心模板。
> 3.  **做题策略**：大题 = 结构体定义 + 核心逻辑模板 + 题目特定修补。

---
- [408 算法代码特训 (Algorithm Templates)](#408-算法代码特训-algorithm-templates)
  - [第一部分：线性表 (Linked List \& Array)](#第一部分线性表-linked-list--array)
    - [1.1 标准起手式 (必背结构体)](#11-标准起手式-必背结构体)
    - [1.2 核心模具一：原地逆置链表 (⭐⭐⭐)](#12-核心模具一原地逆置链表-)
    - [1.3 核心模具二：快慢指针 (⭐⭐⭐)](#13-核心模具二快慢指针-)
      - [(1) 找中间节点 (归并排序常用)](#1-找中间节点-归并排序常用)
      - [(2) 判断链表是否有环 (Cycle Detection)](#2-判断链表是否有环-cycle-detection)
  - [第二部分：真题实战](#第二部分真题实战)
    - [⚔️ 真题演练：2019 年 408 算法题](#️-真题演练2019-年-408-算法题)
  - [第三部分：二叉树 (Recursion)](#第三部分二叉树-recursion)
    - [3.1 标准起手式 (必背结构体)](#31-标准起手式-必背结构体)
    - [3.2 核心模具三：万能递归套路 (⭐⭐⭐⭐⭐)](#32-核心模具三万能递归套路-)
    - [⚔️ 真题实战：2014 年 408 算法题 (带权路径长度 WPL)](#️-真题实战2014-年-408-算法题-带权路径长度-wpl)
    - [🧪 你的任务 (举一反三)](#-你的任务-举一反三)
    - [🧠 逻辑图解 (自底向上)](#-逻辑图解-自底向上)
  - [🚀 第四部分：数组与查找 (Array \& Search)](#-第四部分数组与查找-array--search)
    - [4.1 核心模具四：二分查找标准版 (⭐⭐⭐⭐)](#41-核心模具四二分查找标准版-)
    - [⚔️ 真题实战：2011 年 408 算法题 (两数组的中位数)](#️-真题实战2011-年-408-算法题-两数组的中位数)
    - [💻 代码实现 (模板修补)](#-代码实现-模板修补)
    - [🐢 慢动作解析 (别被奇偶判断吓到)](#-慢动作解析-别被奇偶判断吓到)
    - [🎒 锦囊一：快排划分 (Partition) 的妙用 —— 解决 Top-K 问题](#-锦囊一快排划分-partition-的妙用--解决-top-k-问题)
    - [🎒 锦囊二：层序遍历 (Level Order) —— 解决“树的宽度/非递归”](#-锦囊二层序遍历-level-order--解决树的宽度非递归)
    - [🎒 锦囊三：归并逻辑 (Merge) —— 解决“有序序列合并”](#-锦囊三归并逻辑-merge--解决有序序列合并)

## 第一部分：线性表 (Linked List & Array)

### 1.1 标准起手式 (必背结构体)
不管题目让你干什么，先把这几行写上去，**1分到手**，心里不慌。

```cpp
// 单链表节点定义
typedef struct LNode {
    int data;              // 数据域
    struct LNode *next;    // 指针域
} LNode, *LinkList;

// 数组结构定义 (顺序表)
typedef struct {
    int data[100];         // 静态数组
    int length;            // 当前长度
} SqList;
```

---

### 1.2 核心模具一：原地逆置链表 (⭐⭐⭐)
> **应用场景**：链表反转、回文判断、链表重排、大数加法。
> **核心思想**：**头插法**。把节点一个个摘下来，插到头结点后面。

```cpp
// 模板：将带头结点的链表 L 原地逆置
void Reverse(LinkList L) {
    LNode *p = L->next;    // p 是当前要处理的节点 (旧的第一人)
    LNode *r;              // r 是 p 的后路 (防止断链)
    L->next = NULL;        // 1. 先把头结点摘下来，变成一个空表

    while (p != NULL) {
        r = p->next;       // 2. 记下后路 (r)，否则一会儿 p 断了就找不回去了
        
        // 3. 核心动作：把 p 插到 L 的最前面 (头插)
        p->next = L->next; // p 指向现在的龙头
        L->next = p;       // L 指向 p (p 成了新龙头)
        
        p = r;             // 4. p 继续处理下一个 (刚才记下的 r)
    }
}
```
*   **通俗记忆**：**“摘头、保后路、插队头、下一个”。**

---

### 1.3 核心模具二：快慢指针 (⭐⭐⭐)
> **应用场景**：找中间节点、找倒数第 k 个节点、**判断是否有环**。
> **核心思想**：快指针每次走 2 步，慢指针每次走 1 步。

#### (1) 找中间节点 (归并排序常用)
```cpp
LNode* FindMid(LinkList L) {
    LNode *slow = L, *fast = L;
    // 只要快指针还能走两步，就一直走
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;       // 慢走1
        fast = fast->next->next; // 快走2
    }
    return slow; // 此时 slow 就在中间 (或中间偏右)
}
```

#### (2) 判断链表是否有环 (Cycle Detection)
```cpp
bool HasCycle(LinkList L) {
    LNode *slow = L, *fast = L;
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true; // 快指针套圈追上慢指针了，说明有环
        }
    }
    return false; // 快指针走到头了(NULL)，说明是直路，没环
}
```

---

## 第二部分：真题实战
### ⚔️ 真题演练：2019 年 408 算法题

**题目描述**：
设线性表 $L = (a_1, a_2, a_3, \dots, a_{n-2}, a_{n-1}, a_n)$ 采用带头结点的单链表保存。
请设计一个空间复杂度为 $O(1)$ 且时间上尽可能高效的算法，重新排列 $L$ 中的各结点，得到线性表 $L' = (a_1, a_n, a_2, a_{n-1}, a_3, a_{n-2}, \dots)$。

```cpp
void Reorder(LinkList L) {
    // Step 1: 找中点 (积木二：快慢指针)
    LNode *slow = L, *fast = L;
    while (fast->next != NULL && fast->next->next != NULL) { // 注意：要找左中点，判空条件稍微严格一点
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // Step 2: 断开链表 + 后半段逆置 (积木一：头插逆置)
    LNode *p = slow->next; // p 是后半段的第一个人 (比如 4)
    slow->next = NULL;     // 把前半段断开 (1->2->3->NULL)
    
    // 这里的逆置稍微改一点点：我们没有带头结点的链表给 p 用
    // 所以我们手动逆置 p (或者你把 p 挂到一个临时的头结点 head2 上去逆置，最省事)
    LNode *head2 = (LNode*)malloc(sizeof(LNode)); 
    head2->next = NULL;
    
    // 开始逆置 p 到 head2 后面
    LNode *r;
    while (p != NULL) {
        r = p->next;
        p->next = head2->next;
        head2->next = p;
        p = r;
    }
    // 现在 head2 后面挂的是 5 -> 4
    
    // Step 3: 合并 (链表穿插)
    LNode *q = L->next;      // q 指向前半段第一个 (1)
    p = head2->next;         // p 指向后半段第一个 (5)
    
    while (p != NULL) {
        r = p->next;         // 记下 p 的后路 (4)
        
        // 把 p (5) 插到 q (1) 的后面
        p->next = q->next;   // 5 连上 2
        q->next = p;         // 1 连上 5
        
        // q 跳两步，p 往后走
        q = p->next;         // q 跳到 2
        p = r;               // p 恢复成 4
    }
    
    free(head2); // 别忘了释放那个临时的头
}
```

## 第三部分：二叉树 (Recursion)

---

### 3.1 标准起手式 (必背结构体)

二叉树的结构体定义比链表还简单，但必须写对。

```cpp
typedef struct BiTNode {
    int data;                        // 数据域
    struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;
```

---

### 3.2 核心模具三：万能递归套路 (⭐⭐⭐⭐⭐)

408 的树形大题，80% 都可以用**“后序遍历”**的思维解决。
**心法**：**“分治法”** —— 老板（根节点）不干活，把任务派给左员工（左子树）和右员工（右子树），等他们汇报结果后，老板再汇总。

**通用代码模板（背诵）**：

```cpp
// 模具：对树进行某种统计或计算
int TreeSolver(BiTree T) {
    // 1. 递归出口：如果是空树，返回 0 或 NULL 或特定值
    if (T == NULL) return 0;
    
    // 2. 抛锅：分别去问左边和右边 (递归调用)
    int l_result = TreeSolver(T->lchild);
    int r_result = TreeSolver(T->rchild);
    
    // 3. 汇总：结合我自己的情况，汇报给上级
    // 例如求高度：return (l_result > r_result ? l_result : r_result) + 1;
    // 例如求节点数：return l_result + r_result + 1;
    
    return ...; 
}
```

---

### ⚔️ 真题实战：2014 年 408 算法题 (带权路径长度 WPL)

这道题我们之前在理论部分讲过 WPL 的概念（权值 $\times$ 路径长度）。现在我们要写代码算出来。

**题目描述**：
二叉树的带权路径长度 (WPL) = 所有**叶子节点**的 `weight` $\times$ `depth` (根节点深度为 0) 之和。
请设计算法计算 WPL。

**分析**：
这道题稍微特殊一点，它需要知道“深度”。深度是从上往下传的，所以我们需要用 **“先序遍历” (Top-down)** 的思路。

**解题模具 (参数传递法)**：
我们需要一个辅助函数，多传一个 `depth` 参数。

```cpp
// 核心递归函数
// T: 当前节点, depth: 当前节点的深度
int WPL(BiTree T, int depth) {
    // 1. 递归出口：空树贡献为 0
    if (T == NULL) return 0;
    
    // 2. 核心判断：我是不是叶子？
    // 只有叶子才算钱 (权值 * 深度)
    if (T->lchild == NULL && T->rchild == NULL) {
        return T->data * depth; 
    }
    
    // 3. 如果我不是叶子，WPL = 左边的贡献 + 右边的贡献
    // 注意：传给孩子时，深度要 +1
    return WPL(T->lchild, depth + 1) + WPL(T->rchild, depth + 1);
}

// 4. 包装一下给阅卷老师看 (因为题目通常只给一个 T)
int ComputeWPL(BiTree T) {
    return WPL(T, 0); // 根节点深度从 0 开始
}
```

---

### 🧪 你的任务 (举一反三)

上面的 WPL 是“自顶向下”传参。
现在请你尝试用 **3.2 的万能递归模具 (自底向上)**，解决下面这道经典题：

**题目**：
试编写一个算法，计算一棵二叉树中**所有双分支节点 (度为 2 的节点) 的个数**。

> **提示**：
> 1.  出口：空树返回 0。
> 2.  递归：问左边有多少个 (`l`)？问右边有多少个 (`r`)？
> 3.  汇总：
>     *   如果 `T->lchild != NULL && T->rchild != NULL` (我自己也是双分支)，那我怎么回报？(`l + r + 1`)
>     *   否则 (我不是双分支)，我怎么回报？(`l + r`)

**请尝试写出核心逻辑代码（或者伪代码）！**

```cpp
int CountDouble(BiTree T) {
    // 1. 递归出口：空树，当然是 0 个
    if (T == NULL) return 0;
    
    // 2. 抛锅：先别管我是啥，先去问问我的左右员工
    int l_count = CountDouble(T->lchild); // 左子树里有多少个双分支？
    int r_count = CountDouble(T->rchild); // 右子树里有多少个双分支？
    
    // 3. 汇总：看看我自己是不是双分支？
    if (T->lchild != NULL && T->rchild != NULL) {
        // 我也是！那就在左右的基础上 + 1
        return l_count + r_count + 1;
    } else {
        // 我不是（我是叶子，或者单腿），那我只负责传递左右的结果
        return l_count + r_count;
    }
}
```

### 🧠 逻辑图解 (自底向上)

假设树结构：`A(根) -> B(左), C(右)`。
1.  **A 问 B**：你有多少双分支？ -> B 回复：0。
2.  **A 问 C**：你有多少双分支？ -> C 回复：0。
3.  **A 审视自己**：我有左 B 也有右 C，**我是双分支！**
4.  **A 汇报**：`0 + 0 + 1 = 1`。

---

## 🚀 第四部分：数组与查找 (Array & Search)

408 关于数组的大题，通常有两类：
1.  **二分查找变种**（找中位数、找两个序列的共同数）。
2.  **双指针/逆置技巧**（循环左移、找最小正整数）。

我们重点攻克 **“二分查找 (Binary Search)”** 的大题写法，因为它是“时间复杂度 $O(\log n)$”的代名词。

---

### 4.1 核心模具四：二分查找标准版 (⭐⭐⭐⭐)

虽然我们在笔记里记过，但**大题写法**和**填空**不一样，大题更注重**区间的控制**。

**通用模板（闭区间写法 `[low, high]`）**：
```cpp
// 在有序数组 A 中查找 key，返回下标
int BinarySearch(int A[], int n, int key) {
    int low = 0, high = n - 1, mid;
    
    while (low <= high) { // 只要还有区间没查完
        mid = (low + high) / 2;
        
        if (A[mid] == key) {
            return mid;   // 找到了
        } else if (A[mid] > key) {
            high = mid - 1; // 去左边找，high 左移
        } else {
            low = mid + 1;  // 去右边找，low 右移
        }
    }
    return -1; // 没找到
}
```

---

### ⚔️ 真题实战：2011 年 408 算法题 (两数组的中位数)

这道题非常经典，如果不学算法，很多人会把两个数组合并再排序（复杂度 $O(n)$），但题目要求 $O(\log n)$。

**题目描述**：
两个**等长**的升序序列 A 和 B，长度均为 `n`。请设计算法，找出两个序列合并后的**中位数**。
*(注：中位数是指合并排序后第 `n` 个数)*。

**直觉思维**：
A: `11, 13, 15, 17, 19`
B: `2, 4, 6, 8, 20`
合并：`2, 4, 6, 8, 11, 13, 15, 17, 19, 20`。中位数是 **11**。

**高手思维（减治法/二分）**：
不用真的合并！我们要像**“称重”**一样去比较 A 的中点和 B 的中点。

**解题逻辑**：
1.  比较 A 的中位数 `a_mid` 和 B 的中位数 `b_mid`。
2.  **如果 `a_mid == b_mid`**：那它肯定就是最终的中位数。
3.  **如果 `a_mid < b_mid`**：
    *   说明 A 的**左半边**（比 `a_mid` 还小的）太小了，不可能包含中位数。**舍弃 A 左半边**。
    *   为了保持平衡，同时**舍弃 B 的右半边**（最大的那些）。
    *   *(这就好比：第一名和倒数第一名同时退赛，中位数是不变的)*。
4.  **如果 `a_mid > b_mid`**：舍弃 A 右，舍弃 B 左。
5.  **重复**，直到数组只剩一个数。

---

### 💻 代码实现 (模板修补)



```cpp
int SearchMedian(int A[], int B[], int n) {
    int s1 = 0, d1 = n - 1; // A 的起点终点 (Start, Dest)
    int s2 = 0, d2 = n - 1; // B 的起点终点
    int m1, m2;
    
    while (s1 != d1 || s2 != d2) { // 只要没缩减到只剩一个元素
        m1 = (s1 + d1) / 2;
        m2 = (s2 + d2) / 2;
        
        if (A[m1] == B[m2]) {
            return A[m1]; // 找到了一样的，那就是它了
        }
        
        if (A[m1] < B[m2]) { 
            // A 的中点小 -> 舍弃 A 左边，舍弃 B 右边
            // 细节：如果区间长度是奇数，中点直接保留；如果是偶数，要小心偏移
            // (这里为了好背，我们写一个简化通用的舍弃逻辑)
            if ((s1 + d1) % 2 == 0) { // 奇数个元素
                s1 = m1;      // A 保留 m1 及右边
                d2 = m2;      // B 保留 m2 及左边
            } else {                  // 偶数个元素
                s1 = m1 + 1;  // A 舍弃左半+m1
                d2 = m2;      // B 舍弃右半
            }
        } else {
            // A 的中点大 -> 舍弃 A 右边，舍弃 B 左边
            if ((s1 + d1) % 2 == 0) {
                d1 = m1;
                s2 = m2;
            } else {
                d1 = m1;
                s2 = m2 + 1;
            }
        }
    }
    
    // 最后剩两个数，谁小谁是中位数 (第 n 个)
    return A[s1] < B[s2] ? A[s1] : B[s2];
}
```

---

### 🐢 慢动作解析 (别被奇偶判断吓到)

其实考试时，如果你记不住 `(s1+d1)%2` 这种细节，有一个**“无赖写法”**（也能拿大部分分）：
1.  写出 `while (s1 < d1)`。
2.  里写 `s1 = m1` 或 `d1 = m1`。
3.  最后 return `min(A[s1], B[s2])`。
阅卷老师主要看你**“二分比较、双向舍弃”**的思想（`a_mid < b_mid` 时舍 A 左舍 B 右）。只要这个逻辑对，13 分里能拿 10 分以上。

---

### 🎒 锦囊一：快排划分 (Partition) 的妙用 —— 解决 Top-K 问题

我们之前在排序里学过 `Partition`（挖坑填数）。
**考法变种**：找出数组中**第 k 小**的数，或者把数组分成**两半**（一半大一半小，两半元素个数差最小，和之差最大）。

**代码模板（直接复用排序那章的 Partition，不用改）**：

```cpp
// 这就是之前那个挖坑法的代码，完全一样
int Partition(int A[], int low, int high) {
    int pivot = A[low];
    while (low < high) {
        while (low < high && A[high] >= pivot) high--;
        A[low] = A[high];
        while (low < high && A[low] <= pivot) low++;
        A[high] = A[low];
    }
    A[low] = pivot;
    return low; // 返回基准的最终位置
}

// 妙用：找第 k 小的数 (时间复杂度 O(n))
int FindKth(int A[], int n, int k) {
    int low = 0, high = n - 1;
    while (1) {
        int pos = Partition(A, low, high);
        if (pos == k - 1) return A[pos]; // 找到了
        else if (pos > k - 1) high = pos - 1; // 在左边找
        else low = pos + 1; // 在右边找
    }
}
```
> **一鱼多吃**：只要题目涉及“前 k 个”、“中位数”、“把数组按大小切分”，直接扔出这个模板。

---

### 🎒 锦囊二：层序遍历 (Level Order) —— 解决“树的宽度/非递归”

我们之前用了递归去解树的题。但如果题目强制要求**“非递归”**，或者问**“树的最大宽度”**，递归就不好用了。
这时候必须祭出**队列 (Queue)**。

**代码模板**：

```cpp
// 假设队列操作函数已经有了 (Init, EnQueue, DeQueue, IsEmpty)
void LevelOrder(BiTree T) {
    if (T == NULL) return;
    InitQueue(Q);
    EnQueue(Q, T);
    
    while (!IsEmpty(Q)) {
        BiTree p;
        DeQueue(Q, p);
        visit(p); // 访问节点
        
        if (p->lchild != NULL) EnQueue(Q, p->lchild);
        if (p->rchild != NULL) EnQueue(Q, p->rchild);
    }
}
```
> **变种考法（求最大宽度）**：
> 只需要在 `while` 里面加一层 `for` 循环，把**当前这一层的所有节点**一次性出队，统计个数，就是这一层的宽度。

---

### 🎒 锦囊三：归并逻辑 (Merge) —— 解决“有序序列合并”

这是 2011 年真题（中位数）的基础，也是很多链表/数组合并题的底座。

**代码模板**：
```cpp
// 将有序数组 A 和 B 合并到 C
void Merge(int A[], int n, int B[], int m, int C[]) {
    int i = 0, j = 0, k = 0;
    while (i < n && j < m) {
        if (A[i] < B[j]) 
            C[k++] = A[i++];
        else 
            C[k++] = B[j++];
    }
    // 收尾：剩下的直接接过去
    while (i < n) C[k++] = A[i++];
    while (j < m) C[k++] = B[j++];
}
```

---
