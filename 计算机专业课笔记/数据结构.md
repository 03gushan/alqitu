# 408 数据结构笔记：线性结构篇

<!-- 提示：复制进去后，按 Ctrl+Shift+P 输入 TOC 更新目录 -->
- [408 数据结构笔记：线性结构篇](#408-数据结构笔记线性结构篇)
  - [第1章 线性表 (Linear List)](#第1章-线性表-linear-list)
    - [1.1 逻辑与存储结构](#11-逻辑与存储结构)
      - [顺序表 vs 链表 (选择题必考)](#顺序表-vs-链表-选择题必考)
    - [1.2 顺序表 (Sequence List)](#12-顺序表-sequence-list)
    - [1.3 单链表 (Single Linked List)](#13-单链表-single-linked-list)
    - [1.4 特殊链表 (考点速记)](#14-特殊链表-考点速记)
  - [第2章 栈与队列 (Stack \& Queue)](#第2章-栈与队列-stack--queue)
    - [2.1 核心特性](#21-核心特性)
    - [2.2 循环队列 (Circular Queue)](#22-循环队列-circular-queue)
    - [2.3 难点应用：表达式求值 (中缀转后缀)](#23-难点应用表达式求值-中缀转后缀)
      - [(1) 三种形式](#1-三种形式)
      - [(2) 手算技巧 (加括号法)](#2-手算技巧-加括号法)
      - [(3) 机算逻辑 (单调栈思想) —— 重点](#3-机算逻辑-单调栈思想--重点)
  - [第3章 数组与矩阵 (Arrays)](#第3章-数组与矩阵-arrays)
    - [3.1 数组地址计算](#31-数组地址计算)
    - [3.2 特殊矩阵压缩 (下标转换)](#32-特殊矩阵压缩-下标转换)
  - [第4章 串 (String) —— KMP 深度解析](#第4章-串-string--kmp-深度解析)
    - [4.1 基础概念：前缀与后缀](#41-基础概念前缀与后缀)
    - [4.2 KMP 核心：Next 数组](#42-kmp-核心next-数组)
      - [1. 物理含义 (为什么要算它？)](#1-物理含义-为什么要算它)
      - [2. 手算步骤 (408 必考)](#2-手算步骤-408-必考)
    - [4.3 KMP 进阶：Nextval 数组](#43-kmp-进阶nextval-数组)
      - [1. 为什么要优化？(HR 面试理论)](#1-为什么要优化hr-面试理论)
      - [2. 手算逻辑 (流程图)](#2-手算逻辑-流程图)
  - [第5章 树与二叉树 (Trees \& Binary Trees)](#第5章-树与二叉树-trees--binary-trees)
    - [5.1 核心术语 (避坑指南)](#51-核心术语-避坑指南)
    - [5.2 二叉树 (Binary Tree)](#52-二叉树-binary-tree)
      - [1. 两种特殊二叉树 (必考)](#1-两种特殊二叉树-必考)
      - [2. **上帝公式** (二叉树性质常考)](#2-上帝公式-二叉树性质常考)
      - [3. 完全二叉树的数组性质 (下标计算)](#3-完全二叉树的数组性质-下标计算)
    - [5.3 二叉树的存储结构](#53-二叉树的存储结构)
      - [(1) 顺序存储 (数组)](#1-顺序存储-数组)
      - [(2) 链式存储 (最常用)](#2-链式存储-最常用)
    - [🚀 408 速解技巧：完全二叉树求叶子数](#-408-速解技巧完全二叉树求叶子数)
    - [5.4 二叉树的遍历 (核心代码)](#54-二叉树的遍历-核心代码)
      - [1. 三种遍历的逻辑](#1-三种遍历的逻辑)
      - [2. 递归代码模板 (背诵全文)](#2-递归代码模板-背诵全文)
      - [3. 手算遍历结果 (画图法)](#3-手算遍历结果-画图法)
    - [5.5 层序遍历 (Level Order)](#55-层序遍历-level-order)
    - [5.6 递归算法的“万能套路” (大题必杀)](#56-递归算法的万能套路-大题必杀)
    - [5.7 线索二叉树 (Threaded Binary Tree)](#57-线索二叉树-threaded-binary-tree)
      - [1. 核心逻辑](#1-核心逻辑)
      - [2. 手绘线索 (考试必考)](#2-手绘线索-考试必考)
      - [3. 找后继的口诀 (难点)](#3-找后继的口诀-难点)
  - [第6章 树的应用 (三巨头)](#第6章-树的应用-三巨头)
    - [6.1 二叉排序树 (BST)](#61-二叉排序树-bst)
      - [1. 核心操作 (非递归查找常考)](#1-核心操作-非递归查找常考)
      - [2. 插入与构造](#2-插入与构造)
      - [3. 删除节点 (难点)](#3-删除节点-难点)
    - [6.2 平衡二叉树 (AVL)](#62-平衡二叉树-avl)
      - [1. 背景与定义](#1-背景与定义)
      - [2. 四种失衡与旋转 (理解逻辑)](#2-四种失衡与旋转-理解逻辑)
    - [6.3 哈夫曼树 (Huffman Tree)](#63-哈夫曼树-huffman-tree)
      - [1. 什么是 WPL (带权路径长度)?](#1-什么是-wpl-带权路径长度)
      - [2. 哈夫曼树的定义](#2-哈夫曼树的定义)
      - [3. 构造过程 (哈夫曼编码基础)](#3-构造过程-哈夫曼编码基础)
    - [6.4 树、森林与并查集 (补全盲点)](#64-树森林与并查集-补全盲点)
      - [1. 树的存储结构](#1-树的存储结构)
      - [2. 树、森林与二叉树的转换 (必考手绘)](#2-树森林与二叉树的转换-必考手绘)
      - [3. 遍历的对应关系 (选择题陷阱)](#3-遍历的对应关系-选择题陷阱)
      - [4. 并查集 (Union-Find) —— 考点精简](#4-并查集-union-find--考点精简)
    - [6.5 红黑树 (Red-Black Tree) —— 2022 新增大纲考点](#65-红黑树-red-black-tree--2022-新增大纲考点)
      - [1. 为什么要发明红黑树？](#1-为什么要发明红黑树)
      - [2. 核心定义 (5 条铁律)](#2-核心定义-5-条铁律)
      - [3. 插入调整策略 (看叔叔脸色)](#3-插入调整策略-看叔叔脸色)
  - [第7章 图 (Graphs)](#第7章-图-graphs)
    - [7.1 图的存储结构 (必考)](#71-图的存储结构-必考)
      - [1. 邻接矩阵 (Adjacency Matrix)](#1-邻接矩阵-adjacency-matrix)
      - [2. 邻接表 (Adjacency List)](#2-邻接表-adjacency-list)
      - [3. 十字链表 \& 邻接多重表 (仅供了解)](#3-十字链表--邻接多重表-仅供了解)
    - [7.2 图的遍历 (Traversals)](#72-图的遍历-traversals)
      - [1. 广度优先搜索 (BFS) —— 类似树的层序遍历](#1-广度优先搜索-bfs--类似树的层序遍历)
      - [2. 深度优先搜索 (DFS) —— 类似树的先序遍历](#2-深度优先搜索-dfs--类似树的先序遍历)
    - [7.3 考点对比 (选择题高频)](#73-考点对比-选择题高频)
    - [7.4 最小生成树 (MST)](#74-最小生成树-mst)
      - [1. Prim 算法 (普里姆) —— “抓壮丁”](#1-prim-算法-普里姆--抓壮丁)
      - [2. Kruskal 算法 (克鲁斯卡尔) —— “并查集修路”](#2-kruskal-算法-克鲁斯卡尔--并查集修路)
    - [🧪 现场手推 (必考题型)](#-现场手推-必考题型)
      - [⚡️ 模拟 1：Kruskal 算法 (看全局的边)](#️-模拟-1kruskal-算法-看全局的边)
      - [⚡️ 模拟 2：Prim 算法 (从点 A 出发)](#️-模拟-2prim-算法-从点-a-出发)
    - [7.5 最短路径 (Dijkstra)](#75-最短路径-dijkstra)
      - [1. 算法定义](#1-算法定义)
      - [2. 三个核心数组 (做题工具)](#2-三个核心数组-做题工具)
      - [3. 核心逻辑 (贪心 + 松弛)](#3-核心逻辑-贪心--松弛)
      - [⚔️ 408 避坑指南：Prim vs Dijkstra](#️-408-避坑指南prim-vs-dijkstra)
      - [🧪 现场模拟 (手推填表)](#-现场模拟-手推填表)
        - [第一轮 (初始化)](#第一轮-初始化)
        - [第二轮 (选最小)](#第二轮-选最小)
        - [第三轮 (再选最小)](#第三轮-再选最小)
        - [第四轮](#第四轮)
    - [7.6 多源最短路径 (Floyd 算法)](#76-多源最短路径-floyd-算法)
      - [1. 核心思想](#1-核心思想)
      - [2. 手推过程 (填矩阵 - 必考)](#2-手推过程-填矩阵---必考)
      - [3. 408 做题技巧 (不要傻算)](#3-408-做题技巧-不要傻算)
      - [🧪 现场模拟 (Floyd 观察法)](#-现场模拟-floyd-观察法)
    - [7.7 有向无环图的应用 (DAG) —— 工程管理](#77-有向无环图的应用-dag--工程管理)
      - [1. 拓扑排序 (Topological Sort) - AOV 网](#1-拓扑排序-topological-sort---aov-网)
        - [(1) 算法步骤：图论里的“消消乐”](#1-算法步骤图论里的消消乐)
        - [(2) 实例演示 (必看)](#2-实例演示-必看)
        - [(3) 避坑考点](#3-避坑考点)
      - [2. 关键路径 (Critical Path) - AOE 网](#2-关键路径-critical-path---aoe-网)
        - [(1) 实例模型：西红柿炒蛋](#1-实例模型西红柿炒蛋)
        - [(2) 四个参数的手算 (填表满分攻略)](#2-四个参数的手算-填表满分攻略)
        - [(3) 找关键路径](#3-找关键路径)
  - [第8章 查找 (Searching)](#第8章-查找-searching)
    - [8.1 线性表的查找](#81-线性表的查找)
      - [1. 顺序查找 (Sequential Search)](#1-顺序查找-sequential-search)
      - [2. 折半查找 / 二分查找 (Binary Search) —— 必背](#2-折半查找--二分查找-binary-search--必背)
      - [3. 考点：判定树 (Decision Tree)](#3-考点判定树-decision-tree)
    - [8.2 B 树 (B-Tree) —— 数据结构里的“大魔王”](#82-b-树-b-tree--数据结构里的大魔王)
      - [1. 为什么要发明 B 树？(硬盘 I/O 问题)](#1-为什么要发明-b-树硬盘-io-问题)
      - [2. m 阶 B 树的 5 条铁律 (定义)](#2-m-阶-b-树的-5-条铁律-定义)
      - [3. 核心操作：插入与分裂 (必考手推)](#3-核心操作插入与分裂-必考手推)
      - [4. 核心操作：删除与合并](#4-核心操作删除与合并)
    - [8.3 B+ 树 (B+ Tree) —— 数据库索引原理](#83-b-树-b-tree--数据库索引原理)
      - [1. 结构差异 (死记)](#1-结构差异-死记)
      - [2. 查找行为的区别](#2-查找行为的区别)
      - [3. 为什么数据库选 B+ 不选 B？](#3-为什么数据库选-b-不选-b)
    - [8.4 散列 (Hash Tables)](#84-散列-hash-tables)
      - [1. 基本概念](#1-基本概念)
      - [2. 解决冲突的方法](#2-解决冲突的方法)
      - [3. ASL 计算避坑指南 (必考计算)](#3-asl-计算避坑指南-必考计算)
      - [4. ASL 实战计算模板 (线性探测法)](#4-asl-实战计算模板-线性探测法)
  - [第9章 排序 (Sorting)](#第9章-排序-sorting)
    - [9.1 核心概念](#91-核心概念)
    - [9.2 插入排序 (Insertion Sort)](#92-插入排序-insertion-sort)
      - [1. 直接插入排序 (Straight Insertion)](#1-直接插入排序-straight-insertion)
      - [2. 希尔排序 (Shell Sort) —— 缩小增量](#2-希尔排序-shell-sort--缩小增量)
    - [9.3 交换排序 (Exchange Sort)](#93-交换排序-exchange-sort)
      - [1. 冒泡排序 (Bubble Sort)](#1-冒泡排序-bubble-sort)
      - [2. 快速排序 (Quick Sort) —— **排序之王 (必考)**](#2-快速排序-quick-sort--排序之王-必考)
    - [9.4 选择排序 (Selection Sort)](#94-选择排序-selection-sort)
      - [1. 简单选择排序](#1-简单选择排序)
      - [2. 堆排序 (Heap Sort) —— 必考大难点](#2-堆排序-heap-sort--必考大难点)
      - [3. 堆排序通俗理解](#3-堆排序通俗理解)
    - [9.5 归并排序 (Merge Sort)](#95-归并排序-merge-sort)
      - [1. 核心逻辑：分治 + 合并](#1-核心逻辑分治--合并)
      - [2. 考点分析](#2-考点分析)
    - [9.6 基数排序 (Radix Sort) —— 唯一的异类](#96-基数排序-radix-sort--唯一的异类)
      - [1. 核心逻辑：不比较](#1-核心逻辑不比较)
      - [2. 操作演示 (LSD - 最低位优先)](#2-操作演示-lsd---最低位优先)
      - [3. 考点](#3-考点)
    - [🛑 9.7 排序算法大总结 (考研背诵圣经)](#-97-排序算法大总结-考研背诵圣经)
    - [9.8 外部排序 (External Sort)](#98-外部排序-external-sort)
      - [1. 核心流程](#1-核心流程)
      - [2. 败者树 (Loser Tree) —— 核心优化](#2-败者树-loser-tree--核心优化)
      - [3. 考点计算 (必考)](#3-考点计算-必考)
      - [4. 置换-选择排序 (Replacement Selection)](#4-置换-选择排序-replacement-selection)

---

## 第0章 绪论 (Introduction)

### 0.1 时间复杂度 (Time Complexity)
*   **大O表示法**：关注 $n$ 趋向无穷大时的**数量级**。
*   **常见排序 (从小到大)**：
    $O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(2^n) < O(n!)$
    *   *口诀*：常对幂指阶 (常数 < 对数 < 幂函数 < 指数 < 阶乘)。
*   **运算规则**：
    *   **加法**：$O(f(n)) + O(g(n)) = O(\max(f(n), g(n)))$ (挑大的)。
    *   **乘法**：$O(f(n)) \times O(g(n)) = O(f(n) \times g(n))$ (嵌套循环相乘)。

### 0.2 递归算法复杂度 (Master 定理简化版)
遇到 $T(n) = aT(n/b) + f(n)$ 类型的递归公式：
1.  比较 $n^{\log_b a}$ 和 $f(n)$ 的增长速度。
2.  **谁大听谁的**：如果 $n^{\log_b a}$ 更大，则 $T(n) = O(n^{\log_b a})$。
3.  **一样大乘 log**：如果同阶，则 $T(n) = O(f(n) \times \log n)$。
    *   *例*：二分查找 $T(n) = T(n/2) + 1$。$n^{\log_2 1} = n^0 = 1$。与 $f(n)=1$ 同阶。结果 $O(\log n)$。
  

## 第1章 线性表 (Linear List)

### 1.1 逻辑与存储结构
> **核心考点**：区分逻辑结构和物理结构。
*   **逻辑结构**：**线性**的（一对一，像排队）。
*   **物理结构**：
    1.  **顺序存储（顺序表）**：数组实现，地址连续。
    2.  **链式存储（链表）**：指针实现，地址不连续。

#### 顺序表 vs 链表 (选择题必考)
| 维度 | 顺序表 (Array) | 链表 (LinkedList) | 场景选择 |
| :--- | :--- | :--- | :--- |
| **随机访问** | **支持** $O(1)$ | 不支持 $O(n)$ | 频繁按下标读取时选 |
| **插入/删除** | 慢 $O(n)$ (需搬家) | **快** $O(1)$ (改指针) | 频繁增删时选 |
| **空间分配** | 容易浪费或溢出 | 动态按需申请 | 长度变化大时选 |

### 1.2 顺序表 (Sequence List)
*   **结构定义**：
    ```cpp
    #define MaxSize 50
    typedef struct {
        int data[MaxSize];
        int length;
    } SqList;
    ```
*   **地址计算**：$LOC(a_i) = LOC(a_1) + (i-1) \times L$

### 1.3 单链表 (Single Linked List)
*   **结构定义 (背诵)**：
    ```cpp
    typedef struct LNode {
        int data;
        struct LNode *next;
    } LNode, *LinkList;
    ```
*   **头结点 (Head Node) 的作用**：
    1.  统一第一个位置的操作（不用单独写 if）。
    2.  统一空表和非空表的处理。
*   **核心操作：p 后插 s (先连后断)**：
    ```cpp
    s->next = p->next; // 1. 新人连下家
    p->next = s;       // 2. 老人连新人
    ```

### 1.4 静态链表 (Static Linked List)
*   **定义**：用**数组**来模拟链表。
*   **结构**：`struct { int data; int next; } Node[Max];`
    *   `next` 存的不是指针，是**下个元素的数组下标**。
    *   `next == -1` 表示链表结束。
*   **场景**：不支持指针的语言 (如早期的 Basic, Fortran)。


### 1.5 特殊链表 (考点速记)
1.  **双链表**：
    *   有 `prior` 和 `next`。
    *   **插入顺序 (4步)**：先搞定新节点 s 的两只手，再改 p 和 p->next 的手。
2.  **循环链表**：
    *   **判空**：`L->next == L`
    *   **高频考点**：若需频繁操作**表头和表尾**，使用**带尾指针 (Rear)** 的循环链表，时间复杂度均为 $O(1)$。

---

## 第2章 栈与队列 (Stack & Queue)

### 2.1 核心特性
| 结构 | 特性 | 408 核心应用 |
| :--- | :--- | :--- |
| **栈** | **LIFO** (后进先出) | 递归、括号匹配、**表达式求值**、DFS |
| **队列** | **FIFO** (先进先出) | 缓冲区、层序遍历、BFS |

### 2.2 特殊栈与队列 (易错题高发区)

#### 1. 共享栈 (Shared Stack)
*   **原理**：两个栈共用一个数组。
    *   栈 0 底在 `0`，往右长；栈 1 底在 `Max-1`，往左长。
*   **判满条件**：`top0 + 1 == top1` (两人碰头了)。

#### 2. 双端队列 (Deque) —— 逻辑烧脑题
允许两端都可以进行入队和出队操作。
*   **考点**：给定输入序列 `1, 2, 3, 4`，问哪些输出序列是合法的？
*   **变种限制 (必考)**：
    1.  **输入受限**：一端进，两端出。
    2.  **输出受限**：两端进，一端出。
    *   *做题技巧*：不要死背，画个图，按题目要求模拟进出过程即可。


### 2.3 循环队列 (Circular Queue)
*   **核心思想**：牺牲一个存储单元，解决假溢出。
*   **入队**：`rear = (rear + 1) % MaxSize`
*   **判空**：`front == rear`
*   **判满**：`(rear + 1) % MaxSize == front`
*   **长度**：`(rear - front + MaxSize) % MaxSize`

### 2.4 难点应用：表达式求值 (中缀转后缀)
#### (1) 三种形式
*   中缀：`A + B`
*   后缀 (逆波兰)：`A B +` (计算机执行版)

#### (2) 手算技巧 (加括号法)
1.  按优先级把所有运算加括号。
2.  把符号移到对应的右括号后面。
3.  去掉所有括号。

#### (3) 机算逻辑 (单调栈思想) —— 重点
**规则：**
1.  **数字**：直接**输出**。
2.  **左括号 `(`**：直接**入栈**。
3.  **右括号 `)`**：**清场**。将栈顶直到 `(` 之间的所有符号弹出并输出。
4.  **运算符 (如 +)**：**踢馆**。
    *   如果栈顶符号优先级 **>=** 我：栈顶先弹出输出（强者先算）。
    *   重复直到栈顶比我弱或栈空：我**入栈**。

---

## 第3章 数组与矩阵 (Arrays)

### 3.1 数组地址计算
*   **行优先**：$LOC = \text{基址} + (i \times \text{列数} + j) \times \text{Size}$
*   **列优先**：$LOC = \text{基址} + (j \times \text{行数} + i) \times \text{Size}$

### 3.2 特殊矩阵压缩 (下标转换)
> **技巧**：考试时画 3x3 矩阵代入验证，不要死背公式。

*   **对称矩阵 (存下三角)**：$k = \frac{i(i-1)}{2} + j - 1$ (假设下标从1开始，存入0开始的数组)
*   **三对角矩阵**：$k = 2i + j - 3$

---

## 第4章 串 (String) —— KMP 深度解析

### 4.1 基础概念：前缀与后缀
KMP 的核心在于“利用已匹配部分的信息”，这依赖于对前缀后缀的精准理解。
*   **前缀 (Prefix)**：包含第一个字符，但**不包含最后一个字符**的子串。
    *   *例*：`Harry` 的前缀：`H`, `Ha`, `Har`...
*   **后缀 (Suffix)**：包含最后一个字符，但**不包含第一个字符**的子串。
    *   *例*：`Harry` 的后缀：`y`, `ry`, `rry`...
*   **最长相等前后缀**：
    *   在字符串中找到最长的一段，既是前缀又是后缀。
    *   *例*：`A B A B A` -> 最长是 `A B A` (前) 和 `A B A` (后)，长度为 **3**。

### 4.2 KMP 核心：Next 数组
#### 1. 物理含义 (为什么要算它？)
`next[j] = k` 的含义是：当模式串的**第 `j` 位匹配失败**时，说明前 `j-1` 位是匹配成功的。利用这前 `j-1` 位的**最长相等前后缀**，将模式串**向右滑动**，让第 `k` 位对齐当前主串的位置。

> **形象理解**：**“尺子滑动”**
> 既然“前缀(头)”和“后缀(尾)”长得一样，且“尾”刚才已经匹配过了，那就直接把“头”拖过来，盖在刚才“尾”的位置上，不用重新比了。

#### 2. 手算步骤 (408 必考)
**公式**：`next[j]` = 第 `j` 个字符**前面**子串的**最长相等前后缀长度 + 1**。
*   **规定**：`next[1] = 0`, `next[2] = 1`。

**实战演练**：模式串 `A B A B A`
| j | 当前字符 | **看它前面的子串** | 最长相等前后缀 | 长度 L | **Next[j] = L+1** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | A | (无) | - | - | **0** |
| 2 | B | `A` | 无 | 0 | **1** |
| 3 | A | `A B` | 前`A` 后`B` (不等) | 0 | **1** |
| 4 | B | `A B A` | 前`A` 后`A` (相等) | 1 | **2** |
| 5 | A | `A B A B` | 前`AB` 后`AB` (相等) | 2 | **3** |

### 4.3 KMP 进阶：Nextval 数组
#### 1. 为什么要优化？(HR 面试理论)
*   **Bug**：如果 `S[j]` 匹配失败，`next` 让我跳到 `S[k]`。但如果 **`S[j] == S[k]`** (替补和我长得一样)，那 `S[j]` 失败了，`S[k]` 上去肯定也失败。这是无效尝试。
*   **Fix**：如果是这种情况，直接**跳过**这个替补，去用替补的替补。

#### 2. 手算逻辑 (流程图)
先算出 `next` 数组，然后对于每个 `j`：
1.  看看 **我 (`S[j]`)** 和 **我要跳到的替补 (`S[next[j]]`)** 是不是长得一样？
2.  **如果一样 (S[j] == S[next[j]])**：
    *   说明替补也是废柴。
    *   **`nextval[j] = nextval[next[j]]`** (直接抄袭替补的 nextval，一步到位)。
3.  **如果不一样**：
    *   说明替补有点用，让他上。
    *   **`nextval[j] = next[j]`** (保持原样)。
4.  *注：`nextval[1]` 永远是 0。*

**实战演练**：模式串 `A A A B` (Next: 0 1 2 3)
*   `j=2` (A): 替补是 1号(A)。一样！-> `nextval[2] = nextval[1] = 0`。
*   `j=3` (A): 替补是 2号(A)。一样！-> `nextval[3] = nextval[2] = 0`。
*   `j=4` (B): 替补是 3号(A)。不一样！-> `nextval[4] = next[4] = 3`。
*   结果：`0 0 0 3`。

---


## 第5章 树与二叉树 (Trees & Binary Trees)

### 5.1 核心术语 (避坑指南)
*   **度 (Degree)**：
    *   **节点的度**：它有几个孩子 (分支数)。
    *   **树的度**：树里所有节点中，度**最大**的那个数值。
*   **高度/深度**：
    *   **深度**：从上往下数 (根是第1层)。
    *   **高度**：从下往上数 (叶子是第1层)。
    *   *注：408 通常默认根节点是第 1 层。*
*   **路径长度**：
    *   从节点 A 到 B 经过的**边**的条数 (不是节点数)。

### 5.2 二叉树 (Binary Tree)
> **定义**：每个节点最多 2 个孩子，且**分左右** (有序树)。

#### 1. 两种特殊二叉树 (必考)
| 类型 | 特征 | 存储优势 |
| :--- | :--- | :--- |
| **满二叉树** (Full BT) | **完美金字塔**。高度 $h$，节点数 $2^h - 1$。只有度为0和2的节点。 | 每一层都填满了。 |
| **完全二叉树** (Complete BT) | **金字塔缺右下角**。只有最后一层没满，且叶子全靠左。 | **适合数组存储** (不会有空洞浪费空间)。 |

#### 2. **上帝公式** (二叉树性质常考)
对于任何二叉树，设 $n_0$ 为叶子数，$n_2$ 为度为 2 的节点。
*   **公式**：$n_0 = n_2 + 1$
*   **通俗理解**：**叶子节点**永远比**分叉节点 (度2)** 多一个。
    *   *推导*：总边数 = $n-1$ = $2n_2 + n_1$。联立求解即得。

#### 3. 完全二叉树的数组性质 (下标计算)
如果把完全二叉树存进数组 (下标从 1 开始)：
*   **找孩子**：父节点 $i$ 的左孩子是 $2i$，右孩子是 $2i+1$。
*   **找爸爸**：节点 $i$ 的父节点 is $\lfloor i/2 \rfloor$。
*   **找分界线**：
    *   如果 $i > \lfloor n/2 \rfloor$，则 $i$ 也就是**叶子节点** (没有孩子)。
    *   此性质常用于**堆 (Heap)** 的调整。

### 5.3 二叉树的存储结构
#### (1) 顺序存储 (数组)
*   只适合**完全二叉树**。一般二叉树存进去会浪费大量 `0` 空间。

#### (2) 链式存储 (最常用)
```cpp
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;
```

### 🚀 408 速解技巧：完全二叉树求叶子数

请把这个**推导过程**写在笔记的 `5.2` 节下面，这是针对**完全二叉树 (CBT)** 的特效药。

**原理推导**：
1.  我们知道总节点 $n = n_0 + n_1 + n_2$。
2.  根据上帝公式 $n_2 = n_0 - 1$，带入上式。
3.  得到：$n = n_0 + n_1 + (n_0 - 1) = 2n_0 + n_1 - 1$。
4.  移项整理：**$2n_0 = n + 1 - n_1$**。

**关键点**：
在**完全二叉树**中，$n_1$（只有一个孩子的节点）**要么是 0，要么是 1**。（不可能超过 1 个，否则就不是紧凑排列了）。

**结论（口诀）**：
*   看 **$n$ 是奇数还是偶数**？
*   因为 $2n_0$ 肯定是偶数。
    *   如果 $n$ 是 **奇数** $\rightarrow$ $n_1 = 0$ $\rightarrow$ $n_0 = (n+1)/2$
    *   如果 $n$ 是 **偶数** $\rightarrow$ $n_1 = 1$ $\rightarrow$ $n_0 = n/2$

**🔥 秒杀刚才的题**：
*   题目：$n = 1001$。
*   判断：1001 是**奇数**。
*   秒杀：$n_1 = 0$，所以 $n_0 = (1001 + 1) / 2 = \mathbf{501}$。

*(对比一下你刚才算的 556，是不是这个方法又快又稳？)*

---

### 5.4 二叉树的遍历 (核心代码)

#### 1. 三种遍历的逻辑
这里的“先、中、后”指的是**根节点 (Root)** 什么时候被访问。
*   **先序 (PreOrder)**：**根** -> 左 -> 右
*   **中序 (InOrder)**：左 -> **根** -> 右
*   **后序 (PostOrder)**：左 -> 右 -> **根**

#### 2. 递归代码模板 (背诵全文)
这是所有树形算法的**母题**，必须能默写。

```cpp
// 二叉树节点定义
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 先序遍历
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T);            // 1. 访问根 (干活的地方)
        PreOrder(T->lchild); // 2. 递归左
        PreOrder(T->rchild); // 3. 递归右
    }
}

// 中序遍历：把 visit(T) 放到中间
// 后序遍历：把 visit(T) 放到最后
```

#### 3. 手算遍历结果 (画图法)
考试时给你一棵树图，让你写序列，千万别凭脑子空想，容易晕。
**方法：画轮廓线 (围墙法)**
1.  拿笔从根节点左边开始，沿着树的轮廓**画一圈**，紧贴着树，最后回到根节点。
2.  **先序**：第一次路过节点时，记录它。
3.  **中序**：第二次路过节点 (从左边回来，要去右边时) 记录它。
4.  **后序**：第三次路过节点 (从右边回来，要往上回溯时) 记录它。

---

### 5.5 层序遍历 (Level Order)
> **核心思想**：一层一层切，从左往右扫。
> **数据结构**：必须使用 **辅助队列 (Queue)**。

**代码模板 (手写题常考)**：
```cpp
void LevelOrder(BiTree T) {
    if (T == NULL) return;
    
    InitQueue(Q);       // 1. 初始化队列
    EnQueue(Q, T);      // 2. 根节点入队
    
    BiTree p;
    while (!IsEmpty(Q)) {      // 3. 队列不空就一直循环
        DeQueue(Q, p);         // 4. 出队一个
        visit(p);              // 5. 访问它
        
        // 6. 有左孩子带左孩子入队
        if (p->lchild != NULL) EnQueue(Q, p->lchild);
        // 7. 有右孩子带右孩子入队
        if (p->rchild != NULL) EnQueue(Q, p->rchild);
    }
}
```

---

### 5.6 递归算法的“万能套路” (大题必杀)
408 大题很少直接让你写“遍历”，而是让你“求树高”、“求节点数”、“翻转二叉树”。
**核心心法**：**分治法 (Divide and Conquer)**。
1.  **问左边**：喂，左子树，你有多高？
2.  **问右边**：喂，右子树，你有多高？
3.  **算自己**：我的高度 = Max(左，右) + 1。

**求树深度的代码 (背诵)**：
```cpp
int Depth(BiTree T) {
    if (T == NULL) return 0; // 递归出口：空树高度为0
    
    int l_dep = Depth(T->lchild); // 左子树高度
    int r_dep = Depth(T->rchild); // 右子树高度
    
    // 返回较大者 + 1
    return (l_dep > r_dep ? l_dep : r_dep) + 1;
}
```
> **思考**：这其实是**后序遍历**的变种（左右根）。因为必须先知道孩子的情况，才能汇总算出爸爸的情况。
求书中节点的值比k大的节点的个数
```cpp
int CountK(BiTree T, int k) {
    // 1. 递归出口 (空树)
    if (T == NULL) return 0; 

    // 2. 问左子树 (递归)
    int left_sum = CountK(T->lchild, k); 

    // 3. 问右子树 (递归)
    int right_sum = CountK(T->rchild, k); 

    // 4. 看看自己 (当前节点)
    int my_val = 0;
    if (T->data > k) {  // 题目要求 大于 k
        my_val = 1;
    }

    // 5. 汇总返回
    return left_sum + right_sum + my_val;
}
```
---

### 5.7 线索二叉树 (Threaded Binary Tree)
#### 1. 核心逻辑
*   **背景**：$n$ 个节点的二叉树有 $n+1$ 个空指针。
*   **定义**：利用空指针指向**前驱** (左空) 或 **后继** (右空)。
*   **标志位**：`ltag/rtag`。`0` 表示指孩子，`1` 表示指线索。

#### 2. 手绘线索 (考试必考)
**步骤**：
1.  写出**中序遍历序列**。
2.  **左空连前驱，右空连后继**。
    *   (第一个节点的左指针和最后一个节点的右指针挂空)。

#### 3. 找后继的口诀 (难点)
*   **红灯 (rtag==1)**：直接走，指谁就是谁。
*   **绿灯 (rtag==0)**：有右孩子。后继是**右子树里最左下**的那个节点。
---
## 第6章 树的应用 (三巨头)

### 6.1 二叉排序树 (BST)
> **定义**：**左 < 根 < 右** (对于任意节点都成立)。
> **核心性质**：BST 的**中序遍历**序列是一个**递增序列** (考题突破口)。

#### 1. 核心操作 (非递归查找常考)
*   **查找效率**：
    *   最好情况：$O(\log n)$ (树是胖胖的)。
    *   最坏情况：$O(n)$ (树退化成链表，像糖葫芦一样)。
*   **代码逻辑**：
    ```cpp
    // 查找 val
    while (T != NULL && T->data != val) {
        if (val < T->data) T = T->lchild; // 小就在左边找
        else T = T->rchild;               // 大就在右边找
    }
    return T;
    ```

#### 2. 插入与构造
*   **规则**：新来的总是当**叶子**。
    *   比当前节点小 -> 往左走。
    *   比当前节点大 -> 往右走。
    *   走到空位 -> 坐下 (malloc)。

#### 3. 删除节点 (难点)
如果要删除节点 `z`，分三种情况：
1.  `z` 是叶子：直接删。
2.  `z` 只有一条腿 (左子树或右子树)：子承父业，让孩子顶替 `z` 的位置。
3.  `z` **儿女双全** (最常考)：
    *   **方法**：在 `z` 的**中序前驱** (左子树最右下) 或 **中序后继** (右子树最左下) 中找一个替死鬼 `p`。
    *   **操作**：把 `p` 的值填到 `z` 里，然后把原来的 `p` 删掉 (转为情况 1 或 2)。

> **💡 找替罪羊技巧 (儿女双全时)**：
> *   **找中序前驱**：去左子树，然后一直往右走到底。
> *   **找中序后继**：去右子树，然后一直往左走到底。
> *   **操作技巧**：**不要移动节点指针！** 直接把替罪羊的值 (`data`) 复制给要删除的节点，然后把替罪羊那个节点删掉即可 (替罪羊一定没有左孩子，很好删)。

---

### 6.2 平衡二叉树 (AVL)

#### 1. 背景与定义
*   **目的**：防止二叉排序树退化成链表，保证查找效率稳定在 $O(\log n)$。
*   **定义**：任意节点的**左右子树高度差绝对值不超过 1**。
*   **平衡因子 (BF)**：$BF = H_{左} - H_{右}$。值只能是 -1, 0, 1。

#### 2. 四种失衡与旋转 (理解逻辑)
当插入节点导致某节点 A 失衡 ($|BF|=2$) 时，看**“麻烦”出在哪**：

| 类型 | 麻烦位置 | 形象描述 | 旋转方案 | 谁上位(新根)? |
| :--- | :--- | :--- | :--- | :--- |
| **LL 型** | A 的**左**孩子的**左**边 | 向左撇的直线 `/` | **右单旋** (提住中间，顺时针转) | 儿子 (B) |
| **RR 型** | A 的**右**孩子的**右**边 | 向右撇的直线 `\` | **左单旋** (提住中间，逆时针转) | 儿子 (B) |
| **LR 型** | A 的**左**孩子的**右**边 | 拐弯的小于号 `<` | **先左旋，后右旋** | 孙子 (C) |
| **RL 型** | A 的**右**孩子的**左**边 | 拐弯的大于号 `>` | **先右旋，后左旋** | 孙子 (C) |

> **核心记忆**：
> *   **直的 (LL, RR)**：转一次。中间那个节点上位。
> *   **弯的 (LR, RL)**：转两次。最下面那个“尖尖上”的节点 (孙子) 最终上位。
---

### 6.3 哈夫曼树 (Huffman Tree)

#### 1. 什么是 WPL (带权路径长度)?
*   **路径长度 (Length)**：从根节点到该节点经过的**边数** (层数 - 1)。
*   **权 (Weight)**：节点代表的数值 (频率/重要性)。
*   **WPL 计算公式**：
    $$ WPL = \sum_{\text{所有叶子}} (\text{叶子权值} \times \text{它到根的距离}) $$
*   **通俗理解**：搬运工的体力消耗。重物 (权大) 要放得近 (路径短)，轻物 (权小) 可以放得远。

#### 2. 哈夫曼树的定义
*   **定义**：在所有含 $n$ 个带权叶子节点的二叉树中，**WPL 最小**的那棵树 (也叫最优二叉树)。
*   **特征**：
    *   **权值越大，离根越近**。
    *   只有度为 0 (叶子) 和度为 2 的节点，**没有度为 1 的节点**。

#### 3. 构造过程 (哈夫曼编码基础)
1.  **选小**：在森林中选出两个**根节点权值最小**的树。
2.  **组队**：让它们做一个新节点的左右孩子，新节点权值 = 左+右。
3.  **归队**：把新节点放回森林，老节点踢出。
4.  **重复**：直到只剩一棵树。

### 6.4 树、森林与并查集 (补全盲点)

#### 1. 树的存储结构
普通树（一个节点可以有 N 个孩子）怎么存？
*   **双亲表示法**：用数组存。每个节点记下 `data` 和 `parent` (爸爸的下标)。
    *   *优点*：找爸爸 $O(1)$。*缺点*：找孩子难。
*   **孩子表示法**：用数组+链表（像邻接表的拉链法）。
*   **孩子兄弟表示法 (最重要)**：
    *   **核心法则**：**左孩子右兄弟 (Left-Child, Right-Sibling)**。
    *   **物理结构**：其实就是二叉链表！
        *   `lchild` 指向：**第一个孩子**。
        *   `rchild` 指向：**下一个亲兄弟**。
    *   *考点*：通过这个规则，任何“普通树”都能转换成唯一的一棵“二叉树”。

#### 2. 树、森林与二叉树的转换 (必考手绘)
*   **树 -> 二叉树**：
    1.  **加线**：所有亲兄弟之间连线。
    2.  **抹线**：只保留和**长子**的连线，断开和其他孩子的连线。
    3.  **旋转**：顺时针转 45 度。
*   **森林 -> 二叉树**：
    *   把森林里的每一棵树都变成二叉树。
    *   把第 2 棵树当作第 1 棵树的“右兄弟”连上去，以此类推。

#### 3. 遍历的对应关系 (选择题陷阱)
这是 408 最爱考的“张冠李戴”题。

| 结构 | 遍历方式 | 对应二叉树的遍历 |
| :--- | :--- | :--- |
| **树 (Tree)** | 先根遍历 (PreOrder) | = 二叉树的 **先序** |
| | **后根遍历 (PostOrder)** | = 二叉树的 **中序** (注意! 不是后序) |
| **森林 (Forest)** | 先序遍历 | = 二叉树的 **先序** |
| | **中序遍历** | = 二叉树的 **中序** |

> **记忆口诀**：
> *   普通树没有“中序”，只有先根和后根。
> *   **树的后根** 对应 **二叉树的中序** (因为“右兄弟”代表剩下的部分，后根是最后才访问剩下的)。
> *   **森林的中序** 对应 **二叉树的中序**。

#### 4. 并查集 (Union-Find) —— 考点精简
用于处理“集合合并”和“查关系”的数据结构（数组实现）。
*   **结构**：`S[]` 数组。`S[i]` 存的是父亲的下标。如果 `S[i] < 0`，说明 `i` 是根。
*   **核心操作**：
    1.  **Find(x)**：找 x 的老大（根）。
    2.  **Union(x, y)**：把 x 的老大 和 y 的老大 连起来（让其中一个当另一个的儿子）。
*   **优化 (考代码填空)**：
    *   **路径压缩**：找老大时，把沿途路过的所有人都**直接挂在老大下面**。下次再找就是 $O(1)$。

### 6.5 红黑树 (Red-Black Tree) —— 2022 新增大纲考点

#### 1. 为什么要发明红黑树？
*   **AVL 树的痛点**：太“洁癖”了。要求左右高度差 $\le 1$，导致插入删除时频繁旋转，维护成本高。
*   **红黑树的策略**：**“弱平衡”**。
    *   它允许树歪一点 (最长路径 $\le$ 最短路径的 **2倍**)。
    *   **优势**：插入删除效率高 (旋转少)，查找效率也能接受。
    *   **应用**：Java HashMap, C++ Map, Linux 进程调度。

#### 2. 核心定义 (5 条铁律)
1.  **颜色**：节点非红即黑。
2.  **根**：**根节点**必须是**黑色**。
3.  **叶子**：所有空指针 (NIL) 视为**黑色**叶子。
4.  **不红红**：不能有两个红色节点连在一起 (红爹不能有红儿)。
5.  **黑路同 (灵魂)**：从任一节点到其所有叶子的路径上，**黑色节点的数量必须相同**。
    *   *推论*：因为“黑路同”且“不红红”，所以最短路径(全黑)和最长路径(黑红间隔)的长度差不会超过 2 倍。

#### 3. 插入调整策略 (看叔叔脸色)
*   **默认**：新插入节点一律涂**红色** (破坏黑高难修，破坏红红好修)。
*   **冲突**：如果父节点也是**红** (红红冲突)，看**叔叔 (Uncle)** 的颜色：
    *   **叔叔是红的**：**变色**。
        *   爸、叔变黑，爷爷变红。(爷爷当新节点继续向上看)。
    *   **叔叔是黑的/空的**：**旋转**。
        *   直线 (LL/RR)：转一次 + 变色。
        *   拐弯 (LR/RL)：转两次 + 变色。

## 第7章 图 (Graphs)

### 7.1 图的存储结构 (必考)
图的核心难题是：**多对多**，怎么存进计算机？

#### 1. 邻接矩阵 (Adjacency Matrix)
*   **结构**：二维数组 `A[n][n]`。
*   **规则**：
    *   `A[i][j] = 1` (或权值)：表示节点 i 到 j **有边**。
    *   `A[i][j] = 0` (或 $\infty$)：表示**无边**。
*   **特点**：
    *   **空间复杂度**：$O(n^2)$。只和顶点数有关，跟边数无关。
    *   **适合**：**稠密图** (边很多)。
    *   **算度数**：
        *   无向图：第 i 行之和 = 顶点 i 的度。
        *   有向图：行和 = 出度；列和 = 入度。

#### 2. 邻接表 (Adjacency List)
*   **结构**：**数组 + 链表** (像哈希表的拉链法)。
    *   `VNode` (顶点表)：存数据 + 指向第一条边的指针。
    *   `ArcNode` (边表)：存邻接点下标 + 指向下一条边的指针。
*   **特点**：
    *   **空间复杂度**：
        *   无向图：$O(|V| + 2|E|)$ (每条边存了两次)。
        *   有向图：$O(|V| + |E|)$。
    *   **适合**：**稀疏图** (边很少)。
    *   **注意**：邻接表的表示**不唯一** (取决于链表里节点的链接顺序)，但邻接矩阵是唯一的。

#### 3. 十字链表 & 邻接多重表 (补充)
*   **十字链表 (Orthogonal List)**：
    *   专治**有向图**。
    *   **解决痛点**：邻接表找“入度”太慢。十字链表既存了“出边”，也存了“入边”。容易求度。
*   **邻接多重表 (Adjacency Multilist)**：
    *   专治**无向图**。
    *   **解决痛点**：邻接表存无向边时，一条边存了两份 (i->j 和 j->i)。删除边时要搜两个地方，很麻烦。邻接多重表让一条边只对应一个节点。

---

### 7.2 图的遍历 (Traversals)
图的遍历必须记录 `visited[]` 数组，防止转圈死循环。

#### 1. 广度优先搜索 (BFS) —— 类似树的层序遍历
*   **数据结构**：**队列 (Queue)**。
*   **过程**：
    1.  访问初始点 v，入队。
    2.  队头 u 出队。
    3.  **一次性**把 u 的**所有未访问过的邻居** w1, w2... 放入队列。
    4.  重复直到队空。
*   **应用**：
    *   **最短路径** (仅限无权图)：BFS 第一次访问到某点时，经过的路径一定是最短的。
    *   **BFS 生成树**：遍历过程形成的树。

#### 2. 深度优先搜索 (DFS) —— 类似树的先序遍历
*   **数据结构**：**栈 (Stack)** (常通过递归实现)。
*   **过程**：
    1.  访问 v。
    2.  找 v 的**第一个**邻居 w。
    3.  如果 w 没访问过，**一条路走到黑** (递归调用 DFS(w))。
    4.  如果 w 访问过了，回退找 v 的**下一个**邻居。
   **DFS 不是走到死胡同就结束，而是走到死胡同就“回头”找新路，直到所有点都去过。**
   
---

### 7.3 考点对比 (选择题高频)
| 维度 | 邻接矩阵 | 邻接表 |
| :--- | :--- | :--- |
| **空间** | $O(n^2)$ 固定 | $O(V+E)$ 动态 |
| **判断两点有边** | $O(1)$ 极快 | $O(度)$ 慢 |
| **找所有邻居** | $O(n)$ 慢 (要扫描一行) | $O(度)$ 快 |
| **唯一性** | 唯一 | 不唯一 |


### 7.4 最小生成树 (MST)

---

#### 1. Prim 算法 (普里姆) —— “抓壮丁”

*   **适合场景**：**稠密图** (边多)。
*   **核心逻辑**：
    1.  **建群**：随便选一个点（比如 A）作为“已选集合”。
    2.  **诱惑**：看所有**连接“已选集合”与“未选集合”的边**。
    3.  **抓人**：选一条**最短**的边，把对面的那个点抓进群。
    4.  **重复**：直到所有人都进群。

> **记忆口诀**：**Prim 是“点找点”，谁离我最近，我就把谁拉入伙。**

#### 2. Kruskal 算法 (克鲁斯卡尔) —— “并查集修路”

*   **适合场景**：**稀疏图** (边少)。
*   **核心逻辑**：
    1.  **排序**：把所有的边按权值**从小到大**扔在一个列表里。
    2.  **选边**：拿出最小的一条边。
    3.  **判圈 (并查集核心)**：
        *   这两个点是不是**已经连通**了（是不是同一个老大）？
        *   **是**：跳过（否则会形成回路/环）。
        *   **否**：选中这条边，**Union** 这两个帮派。
    4.  **重复**：直到选够 $n-1$ 条边。

> **记忆口诀**：**Kruskal 是“边找边”，先修最便宜的路，只要不转圈就行。**

---

### 🧪 现场手推 (必考题型)

为了让你一次性记住这两个的区别，我们用同一个图来模拟。

**图结构 (无向带权图)**：
*   顶点：A, B, C, D
*   边权：
    *   (A, B) = 1
    *   (B, C) = 4
    *   (C, D) = 2
    *   (A, C) = 10
    *   (B, D) = 5

---

#### ⚡️ 模拟 1：Kruskal 算法 (看全局的边)
1.  **列出所有边并排序**：
    *   (A, B) = 1
    *   (C, D) = 2
    *   (B, C) = 4
    *   (B, D) = 5
    *   (A, C) = 10
2.  **第一步**：选最小 **(A, B) = 1**。连上。
3.  **第二步**：选次小 **(C, D) = 2**。连上。
4.  **第三步**：选第三小 **(B, C) = 4**。
    *   检查：B 和 C 连通了吗？目前没有（A-B 一伙，C-D 一伙）。
    *   **连上！** (现在大家都连通了)。
5.  **结束**：选够 3 条边了。总花费 = 1+2+4 = 7。

---

#### ⚡️ 模拟 2：Prim 算法 (从点 A 出发)
1.  **初始**：已选集合 `{A}`。
2.  **第一轮**：
    *   A 能连出去的边：(A,B)=1, (A,C)=10。
    *   选最小：**(A, B) = 1**。
    *   **B 入伙**。集合 `{A, B}`。
3.  **第二轮**：
    *   A 或 B 能连出去（且连向外面）的边：(A,C)=10, (B,C)=4, (B,D)=5。
    *   选最小：**(B, C) = 4**。
    *   **C 入伙**。集合 `{A, B, C}`。
4.  **第三轮**：
    *   A, B, C 能连出去的边：(A,C)无效(都在群里), (B,D)=5, (C,D)=2。
    *   选最小：**(C, D) = 2**。
    *   **D 入伙**。
5.  **结束**。总花费 = 1+4+2 = 7。

> **关于 MST 的唯一性 (选择题考点)**：
> 1.  **权值之和 (Cost)**：Prim 和 Kruskal 算出来的结果**一定相同** (都是最小值)。
> 2.  **树的形状 (Shape)**：
>     *   如果图中**所有边的权值都不相同**，则 MST 的形状**唯一**。
>     *   如果图中**有权值相同的边**，则 MST 的形状**可能不唯一** (有好几种连法，但总花费一样)。

### 7.5 最短路径 (Dijkstra)

#### 1. 算法定义
*   **功能**：计算**单源**最短路径 (从起点 $V_0$ 到其余所有顶点的最短距离)。
*   **限制**：**图中不能有负权值的边** (否则算法失效，得用 Floyd 或 Bellman-Ford)。
*   **时间复杂度**：$O(n^2)$ (和 Prim 一样)。

#### 2. 三个核心数组 (做题工具)
假设起点是 0 号节点：
1.  `final[i]` (标记数组)：记录节点 $i$ 是否已经找到了最短路径 (是否已“归位”)。
2.  **`dist[i]` (距离数组 - 核心)**：记录当前从起点 0 到节点 $i$ 的最短距离。
    *   初始时：自己到自己是 0，到邻居是边权，到不连通的是 $\infty$。
3.  `path[i]` (路径数组)：记录节点 $i$ 的前驱是谁 (为了复原路径)。

#### 3. 核心逻辑 (贪心 + 松弛)
1.  **选最小**：从 `dist` 数组里找一个**没归位** (`final`为false) 且 **数值最小** 的顶点 $u$。
2.  **归位**：标记 `final[u] = true` ($u$ 的最短路定死了，以后不动了)。
3.  **松弛 (Relax)**：以 $u$ 为跳板，看能不能优化别人的距离。
    *   **公式**：如果 `dist[u] + weight(u, v) < dist[v]`，
    *   **更新**：`dist[v] = dist[u] + weight(u, v)`。
    *   (通俗说：**我发现了一条经过 $u$ 到 $v$ 的路，比原来的路更近，赶紧更新！**)
4.  **循环**：重复 $n-1$ 次，直到所有点都归位。


---

#### ⚔️ 408 避坑指南：Prim vs Dijkstra

这两个算法的代码长得几乎一模一样，填表过程也很像，**极容易搞混**。
请务必把下面这个对比记在心里：

| 维度 | Prim (最小生成树) | Dijkstra (最短路径) |
| :--- | :--- | :--- |
| **dist数组存什么?** | 存节点到 **“已选集合”** 的距离 | 存节点到 **“起点 $V_0$”** 的**累加**距离 |
| **核心差异** | **不累加** (只看最后一条边) | **累加** (起点到我 + 我到你) |
| **目的** | 连通全图，总权值最小 | 找出起点的最短路 |

---

#### 🧪 现场模拟 (手推填表)

我们用一个简单的图来演示“累加”的过程。
**图结构**：
*   0 -> 1 (权值 10)
*   0 -> 2 (权值 5)
*   2 -> 1 (权值 3)   <-- 注意这条路
*   1 -> 3 (权值 1)
*   2 -> 3 (权值 9)

**起点：0**。

##### 第一轮 (初始化)
*   **归位**：{0}
*   **dist 状态**：
    *   `dist[1] = 10` (直接到)
    *   `dist[2] = 5` (直接到)
    *   `dist[3] = \infty` (到不了)

##### 第二轮 (选最小)
*   **选人**：在 10, 5, $\infty$ 里选最小 -> **选 2**。
*   **归位**：{0, 2}
*   **松弛 (借道 2)**：
    *   看看通过 2 能不能让别人更近？
    *   **看 1**：原来 0->1 是 10。现在 0->2->1 是 $5 + 3 = 8$。
        *   **8 < 10，更新！** `dist[1] = 8`。
    *   **看 3**：原来是 $\infty$。现在 0->2->3 是 $5 + 9 = 14$。
        *   更新！`dist[3] = 14`。
*   **当前 dist**：`[0, 8, 5, 14]` (注意 1 变成 8 了)。

##### 第三轮 (再选最小)
*   **选人**：剩下的没归位的有 1 (是8), 3 (是14)。**选 1**。
*   **归位**：{0, 2, 1}
*   **松弛 (借道 1)**：
    *   看看通过 1 能不能优化别人？
    *   **看 3**：原来 0->...->3 是 14 (0->2->3)。
    *   现在走新路：0->2->1->3。距离是 `dist[1] + 1` = $8 + 1 = 9$。
    *   **9 < 14，更新！** `dist[3] = 9`。
*   **当前 dist**：`[0, 8, 5, 9]`。

##### 第四轮
*   选 3，结束。

---

### 7.6 多源最短路径 (Floyd 算法)

#### 1. 核心思想
*   **目的**：求任意两点 $(i, j)$ 之间的最短距离。
*   **逻辑**：**暴力枚举中转点**。
    *   问：从 $i$ 直接到 $j$ 近？还是从 $i$ 经过 $k$ 再到 $j$ 近？
*   **公式**：$A[i][j] = \min(A[i][j], \ A[i][k] + A[k][j])$

#### 2. 手推过程 (填矩阵 - 必考)
我们维护两个矩阵：
*   **$A$ (距离矩阵)**：存最短距离 (初始化就是邻接矩阵，不通的是 $\infty$)。
*   **$Path$ (路径矩阵)**：存中转点 (初始化都是 -1)。

**迭代步骤**：
一共进行 $n$ 轮 (假设节点是 0, 1, 2)。
*   **第 0 轮**：允许以 **0号节点** 作为中转站。
    *   检查所有格子：$A[i][j]$ 是否大于 $A[i][0] + A[0][j]$？
    *   如果是，更新 $A[i][j]$。
*   **第 1 轮**：允许以 **0号、1号** 作为中转站。
    *   检查：$A[i][j]$ 是否大于 $A[i][1] + A[1][j]$？
*   **第 2 轮**：允许以 **0,1,2** 作为中转站。
    *   ...

#### 3. 408 做题技巧 (不要傻算)
考试如果让你画 Floyd 的矩阵变化，千万别写 3 重循环算几百次。
**观察法**：
1.  **画圈法**：
    *   如果要加入 **k号** 中转点。
    *   先把矩阵的 **第 k 行** 和 **第 k 列** 圈起来（这两行两列的数值在这一轮**永远不会变**）。
    *   还要把 **主对角线** (自己到自己) 圈起来（永远是 0）。
2.  **只看没圈的**：
    *   剩下的格子，每一个都用“十字交叉法”看一眼。
    *   比如看 $A[x][y]$，就看它对应的 **第 k 行那个数** 和 **第 k 列那个数** 加起来是不是比自己小。


---

#### 🧪 现场模拟 (Floyd 观察法)

我们用刚才 Dijkstra 那个图来试一下 Floyd 的第一轮。
**图**：
*   0 -> 1 (权值 10)
*   0 -> 2 (权值 5)
*   2 -> 1 (权值 3)   <-- 注意这条路
*   1 -> 3 (权值 1)
*   2 -> 3 (权值 9)

**初始矩阵 A0** (行是起点，列是终点)：
```text
      0   1   2   3
0 |   0  10   5  inf
1 | inf   0 inf   1
2 | inf   3   0   9
3 | inf inf inf   0
```

**现在进行“k=0”这一轮（允许经过 0 号点中转）**：

1.  **圈死**：第 0 行、第 0 列、对角线。这些不用看，照抄。
2.  **看剩下的**：
    *   比如看 **A[2][1]** (原本是 3)：
        *   看经过 0 中转：$A[2][0] (\infty) + A[0][1] (10) = \infty$。
        *   3 < $\infty$，**不更新**。
    *   比如看 **A[2][3]** (原本是 9)：
        *   看经过 0 中转：$A[2][0] (\infty) + A[0][3] (\infty) = \infty$。
        *   不更新。

**结论**：因为 2 号根本去不了 0 号 (单向边)，所以以 0 做中转没用。这一轮矩阵没变。

**假如进行“k=2”这一轮（允许经过 2 号点中转）。我们看 `A[0][1]` (原本是 10)：**
*   经过 2 中转：$A[0][2] (5) + A[2][1] (3) = 8$。
*   **8 < 10，更新！**
*   这就对应了 Dijkstra 算出来的那个结果。

### 7.7 有向无环图的应用 (DAG) —— 工程管理

#### 1. 拓扑排序 (Topological Sort) - AOV 网
> **AOV (Activity On Vertex)**：用**顶点**表示活动。比如“顶点A=洗袜子”。
> **核心逻辑**：解决**“先后依赖”**问题。想穿鞋(B)，必须先穿袜子(A)。

##### (1) 算法步骤：图论里的“消消乐”
1.  **找 0**：在图里找一个**入度为 0** (没人指向我/没有前置任务) 的顶点。
2.  **消掉**：把它输出，并且**删掉**它连出去的所有箭头。
3.  **更新**：其他顶点的入度会减少，重复步骤 1。

##### (2) 实例演示 (必看)
**场景**：大学选课。
*   **规则**：学《数据结构》(C) 之前，必须修完《C语言》(A) 和 《离散数学》(B)。
*   **图结构**：
    *   A -> C
    *   B -> C
    *   C -> D (毕业设计)

**手推过程**：
1.  **第一轮**：找入度为 0 的。**A** 和 **B** 都是 0。
    *   *选 A*。输出 `A`。删掉 A->C 的箭头。
    *   *图变成*：B->C, C->D。
2.  **第二轮**：找入度为 0 的。**B** 是 0（C 还不是，因为 B 指着它）。
    *   *选 B*。输出 `B`。删掉 B->C 的箭头。
    *   *图变成*：C->D。
3.  **第三轮**：找入度为 0 的。**C** 终于变成 0 了。
    *   *选 C*。输出 `C`。删掉 C->D。
4.  **第四轮**：输出 `D`。
*   **最终序列**：`A, B, C, D` 或 `B, A, C, D` (说明序列**不唯一**)。

##### (3) 避坑考点
*   **有环**：如果图里还有点，但找不着入度为 0 的了（互相指，死循环），说明**有环**，工程无法完成。
*   **逆拓扑排序**：就是 DFS 遍历时，**节点出栈**（回溯完成）的顺序的倒序。

---

#### 2. 关键路径 (Critical Path) - AOE 网
> **AOE (Activity On Edge)**：用**边**表示活动。比如“边<1,2>=炒菜过程(3分钟)”。
> **核心逻辑**：**“木桶效应”的反面**。整个工程最早啥时候完工，取决于**最慢（最长）**的那条路径。

##### (1) 实例模型：西红柿炒蛋
假设工程图如下（数字代表天数）：
*   Start(0) -> [a:5] -> 洗好(1) -> [c:3] -> End(3)
*   Start(0) -> [b:2] -> 打好(2) -> [d:1] -> End(3)
*   *(注：0是起点，3是终点。上面那条路总长 5+3=8，下面那条路总长 2+1=3)*

##### (2) 四个参数的手算 (填表满分攻略)

**第一阶段：算顶点 (事件发生的时刻)**

1.  **`ve(k)` 最早时刻** —— **从前往后推，取最大** (必须等人齐)。
    *   `ve(0)` = 0。
    *   `ve(1)` (洗好) = 0 + 5 = **5**。
    *   `ve(2)` (打好) = 0 + 2 = **2**。
    *   `ve(3)` (End)：
        *   上路：5 + 3 = 8。
        *   下路：2 + 1 = 3。
        *   **决断**：必须等慢的那个做完才能开饭。取 **8**。

2.  **`vl(k)` 最迟时刻** —— **从后往前推，取最小** (死线倒推)。
    *   `vl(3)` = 8 (总工期定死为8)。
    *   `vl(1)` (洗好) = 8 - 3 = **5** (必须在第5天洗完，不然耽误吃饭)。
    *   `vl(2)` (打好) = 8 - 1 = **7** (第7天打完鸡蛋都来得及，因为后面只花1天)。
    *   `vl(0)` (Start) = min(5-5, 7-2) = 0。

**第二阶段：算边 (活动拖延潜力)**
我们要找出哪条边是“不能摸鱼”的。

3.  **`e(i)` 活动最早** = **起点的 ve** (起点只要发生了，我就能开工)。
    *   活动 a (洗西红柿): 起点是 0 -> `e = 0`。
    *   活动 b (打鸡蛋): 起点是 0 -> `e = 0`。

4.  **`l(i)` 活动最迟** = **终点的 vl - 耗时** (终点死线减去我要花的时间)。
    *   活动 a: 终点是 1 (vl=5) - 耗时5 = `l = 0`。
    *   活动 b: 终点是 2 (vl=7) - 耗时2 = `l = 5`。

##### (3) 找关键路径
*   **判据**：`e(i) == l(i)` 的活动。
    *   **活动 a**：最早 0，最迟 0。**关键！** (一点不能拖)。
    *   **活动 b**：最早 0，最迟 5。**非关键** (可以摸鱼 5 天)。
*   **结论**：关键路径是 `Start -> 1 -> End` (洗西红柿那条线)。
*   **性质**：
    *   关键路径可能**不止一条**。
    *   **缩短工期**：必须缩短**关键路径**上的活动时间。
    *   **坑点**：如果缩太狠，原来的非关键路径可能变成关键路径（本来打鸡蛋很快，结果你洗西红柿用秒光速洗完，那打鸡蛋就成瓶颈了）。


## 第8章 查找 (Searching)

### 8.1 线性表的查找

#### 1. 顺序查找 (Sequential Search)
*   **普通版**：从头比到尾。
*   **哨兵版 (Sentinel)**：
    *   **做法**：把 `A[0]` 留空，把要查的 `key` 放在 `A[0]`，然后从后往前找。
    *   **优势**：**省去越界检查**。循环里不需要判断 `i >= 0`，因为 `A[0]` 一定相等，会自动停下。效率稍微高丢丢。

#### 2. 折半查找 / 二分查找 (Binary Search) —— 必背
*   **前提**：必须是**有序**的**顺序表** (链表不行，因为没法直接跳到中间)。
*   **代码模板 (闭区间写法)**：
    ```cpp
    int BinarySearch(int A[], int n, int key) {
        int low = 0, high = n - 1, mid;
        while (low <= high) {            // 核心细节：是 <= 不是 <
            mid = (low + high) / 2;      // 只有数组支持随机访问
            if (A[mid] == key) return mid;
            else if (A[mid] > key) high = mid - 1; // 去左半边
            else low = mid + 1;                    // 去右半边
        }
        return -1; // 没找到
    }
    ```

#### 3. 考点：判定树 (Decision Tree)
这不是一种存储结构，而是用来**分析二分查找效率**的工具。
*   **原理**：把二分查找的“比较过程”画成一棵树。
    *   **圆形节点**：代表表中存在的元素（查找成功）。
    *   **方形节点**：代表空隙/空指针（查找失败）。
*   **性质**：判定树是一棵**平衡二叉排序树 (BST)**。
*   **ASL (平均查找长度) 计算**：
    *   **ASL(成功)** = $\sum (\text{层数} \times \text{该层节点数}) / \text{总节点数}$。
    *   **ASL(失败)** = $\sum (\text{方形节点所在层数-1} \times \text{该层方形节点数}) / \text{方形节点总数}$。

---

### 8.2 B 树 (B-Tree) —— 数据结构里的“大魔王”

#### 1. 为什么要发明 B 树？(硬盘 I/O 问题)
*   **痛点**：AVL 树太高了。如果数据在硬盘上，查一个数要几十层，就要读几十次硬盘（慢）。
*   **方案**：把树**压扁**。让一个节点存**很多个**关键字，并且有**很多个**分叉。
*   **结果**：变成了**“矮胖子”**。存储亿级数据可能只需要 3-4 层。

#### 2. m 阶 B 树的 5 条铁律 (定义)
假设是 **5 阶 (m=5)** B 树：
1.  **最大孩子数**：$m = 5$。
2.  **最大关键字数**：$m - 1 = 4$。（房间最多住 4 人，第 5 人进来就爆炸分裂）。
3.  **最小关键字数**：$\lceil m/2 \rceil - 1 = \lceil 2.5 \rceil - 1 = 2$。（除了根，房间不能太空，至少住 2 人）。
4.  **绝对平衡**：所有**叶子节点**都在**同一层**。（绝对不会出现左腿长右腿短）。
5.  **有序性**：节点内有序（像数组），节点间有序（像 BST）。

#### 3. 核心操作：插入与分裂 (必考手推)
**场景演示**：5 阶 B 树 (上限 4 个数)，节点已有 `20, 30, 40, 50`。
1.  **插入 60**：节点变成 `20, 30, 40, 50, 60` (5 个数，超载！)。
2.  **找中间**：中间数是 **40**。
3.  **提拔**：**40** 升职，去上一层（父节点）。
4.  **分家**：
    *   `20, 30` 留在左边做新孩子。
    *   `50, 60` 去右边做新孩子。
> **注意**：B 树是**“向上生长”**的。只有根节点分裂时，树才会长高一层。

#### 4. 核心操作：删除与合并
1.  **不够借 (Merge)**：兄弟也没余粮。
    *   **操作**：兄弟 + 父节点中间那个数 + 我 = **三合一**，合并成一个新节点。
2.  **够借 (Rotate)**：兄弟富裕。
    *   **操作**：**父子换位**。兄弟最大的给爸爸，爸爸下来的给我。

---

### 8.3 B+ 树 (B+ Tree) —— 数据库索引原理

#### 1. 结构差异 (死记)
| 特性 | B 树 (标准版) | B+ 树 (进阶版) |
| :--- | :--- | :--- |
| **数据存储** | 所有节点都存真实数据 | **只有叶子**存数据，上面全是路牌(索引) |
| **关键字重复** | 关键字不重复 (在哪找到就在哪) | **重复** (上面的路牌在底下叶子里必有一份) |
| **孩子个数** | $n$ 个关键字 $\to$ $n+1$ 个孩子 | **$n$ 个关键字 $\to$ $n$ 个孩子** (一一对应) |
| **叶子链接** | 叶子之间没关系 | 叶子连成一条**单链表** (支持范围查询) |

#### 2. 查找行为的区别
*   **B 树**：
    *   类似于二分查找。
    *   **不稳定**：有时候在根就找到了(快)，有时候在叶子才找到(慢)。
*   **B+ 树**：
    *   **稳定**：无论查谁，都必须**从根走到叶子**。
    *   **范围查找**：`Select * where id > 10`。B+ 树找到 10 以后，直接遍历链表，效率极高。

#### 3. 为什么数据库选 B+ 不选 B？
1.  **更矮胖**：因为 B+ 树的中间节点不存数据（只存路牌），所以同样大小的磁盘块，B+ 树能塞下更多的关键字。这意味着树的**分叉更多，层数更少**，磁盘 I/O 更少。
2.  **扫库快**：做全表扫描时，B+ 树只要遍历叶子链表；B 树得遍历整棵树。
---

### 8.4 散列 (Hash Tables)

#### 1. 基本概念
*   **原理**：通过公式 `Addr = H(key)` 直接算出地址，理想时间复杂度 $O(1)$。
*   **冲突 (Collision)**：不同的 key 算出了同一个地址。
*   **装填因子 ($\alpha$)**：$\alpha = n/m$ (装得越满，冲突概率越大)。

#### 2. 解决冲突的方法
1.  **开放定址法 (Open Addressing)**：哪怕不是我家，只要空着我就住。
    *   **线性探测**：`d, d+1, d+2...` (挨个往后找坑位，容易产生“堆积”现象)。
    *   **平方探测**：`d+1^2, d-1^2, d+2^2...` (双向跳跃找坑位)。
2.  **拉链法 (Chaining)**：(最常用)
    *   每个地址挂一个链表，冲突的元素都挂在链表上。

#### 3. ASL 计算避坑指南 (必考计算)
**题目**：表长 10，模数 $P=7$ (即 H(k) = k % 7)，线性探测。
**ASL(成功)**：
*   分子：所有元素的“查找次数”之和。
*   分母：**元素个数**。

**ASL(失败) —— 易错！**：
*   **分子**：查找表中 **0 ~ P-1** (注意是 0 到 6) 这些位置，需要比较几次才能发现“这里是空的/找不到”。
*   **分母**：**模数 P** (这里是 7，不是表长 10！)。
    *   *逻辑*：因为 Hash 函数只能算出 0~6，所以如果不成功，只可能落在这 7 个位置上。

#### 4. ASL 实战计算模板 (线性探测法)
**例题**：Hash(k) = k % 7，插入 14, 8, 21。
**表状态**：`[14, 8, 21, 空, ...]` (21 冲突后占了 2 号位)

1.  **ASL(成功)**：
    *   14 在 0 号 (算出来是0) -> 1 次。
    *   8 在 1 号 (算出来是1) -> 1 次。
    *   21 在 2 号 (算出来是0) -> 看了 0, 1, 2 -> 3 次。
    *   **Result** = (1+1+3)/3 = 5/3。

2.  **ASL(失败)**：(分母是 7)
    *   H=0: 看 0,1,2,3(空) -> 4 次。
    *   H=1: 看 1,2,3(空) -> 3 次。
    *   H=2: 看 2,3(空) -> 2 次.
    *   H=3: 看 3(空) -> 1 次。
    *   H=4,5,6: 各 1 次。
    *   **Result** = (4+3+2+1+1+1+1)/7 = 13/7。

## 第9章 排序 (Sorting)

### 9.1 核心概念
*   **稳定性 (Stability)**：
    *   **定义**：如果 `A` 和 `B` 的值相等，排序前 `A` 在 `B` 前面，排序后 `A` 依然在 `B` 前面，叫**稳定**。
    *   *口诀*：**“快些选堆”** (快排、希尔、选择、堆排) 是**不稳定**的。（心情不稳定，快些选堆朋友去玩）。

---

### 9.2 插入排序 (Insertion Sort)
#### 1. 直接插入排序 (Straight Insertion)
*   **逻辑**：**打扑克摸牌**。
    *   手里有一把排好的牌，摸一张新牌，从后往前比，找到位置插进去。
*   **考点**：
    *   **最好**：有序 -> $O(n)$。
    *   **最坏**：逆序 -> $O(n^2)$。
    *   **稳定性**：**稳定**。
#### 1.5 折半插入排序 (Binary Insertion Sort)
*   **改良点**：在有序区寻找插入位置时，不用“从后往前挨个比”，而是用**“二分查找”**。
*   **性能**：
    *   **比较次数**：减少了 (变成了 $O(n \log n)$ 量级)。
    *   **移动次数**：**没变！** (找到位置后，还得把后面的元素一个个往后挤)。
    *   **总复杂度**：依然是 $O(n^2)$。
    *   **稳定性**：**稳定**。

#### 2. 希尔排序 (Shell Sort) —— 缩小增量
*   **逻辑**：**跳着分组 + 组内插入**。
    1.  选增量 $d$ (比如 $n/2$)，把距离为 $d$ 的元素当成一组。
    2.  组内进行直接插入排序。
    3.  $d$ 减半，重复... 直到 $d=1$。
*   **考点**：
    *   **手推**：通常考 $d_1$ 这一趟排序后的序列。
    *   **稳定性**：**不稳定** (因为相同的数可能被分到不同组，乱跳)。

---

### 9.3 交换排序 (Exchange Sort)
#### 1. 冒泡排序 (Bubble Sort)
*   **逻辑**：**两两比较，大数沉底**。
    *   一趟下来，**最大**的那个数一定会跑到最后面固定下来。
*   **考点**：
    *   **稳定性**：**稳定**。
    *   **标志位优化**：如果一趟比较中没有发生任何交换，说明已有序，直接结束。

#### 2. 快速排序 (Quick Sort) —— **排序之王 (必考)**
*   **核心逻辑 (分治法)**：
    1.  **选基准 (Pivot)**：通常选第一个元素 `A[low]`。
    2.  **划分 (Partition)**：
        *   **High 指针**：从右往左，找比基准**小**的，扔到左边坑里。
        *   **Low 指针**：从左往右，找比基准**大**的，扔到右边坑里。
        *   **相遇**：把基准填入相遇点。
    3.  **递归**：对左边和右边分别做快排。
*   **代码模板 (大题默写必备)**：
    ```cpp
    // 核心：划分函数 (挖坑填数法)
    int Partition(int A[], int low, int high) {
        int pivot = A[low]; // 1. 选基准，挖坑
        while (low < high) {
            // 2. High 找小，填 Low 坑
            while (low < high && A[high] >= pivot) high--;
            A[low] = A[high];
            // 3. Low 找大，填 High 坑
            while (low < high && A[low] <= pivot) low++;
            A[high] = A[low];
        }
        A[low] = pivot; // 4. 基准归位
        return low;
    }
    
    void QuickSort(int A[], int low, int high) {
        if (low < high) {
            int pos = Partition(A, low, high); // 一分为二
            QuickSort(A, low, pos - 1);        // 排左边
            QuickSort(A, pos + 1, high);       // 排右边
        }
    }
    ```
*   **性能分析**：
    *   **最好**：每次基准都正好切在中间 (树平衡) -> $O(n \log n)$。
    *   **最坏**：本来就有序 (树退化成链表) -> $O(n^2)$。
    *   **空间**：需要递归栈，平均 $O(\log n)$。
    *   **稳定性**：**不稳定**。

### 9.4 选择排序 (Selection Sort)
#### 1. 简单选择排序
*   **逻辑**：每次从后面剩下的牌里挑一张**最小的**，跟当前的交换。
*   **考点**：
    *   **不稳定** (比如 `2, 2, 1`，为了把 1 换到前面，第一个 2 会跑到第二个 2 后面)。
    *   **比较次数**与初始状态无关 (永远是 $n(n-1)/2$)。

#### 2. 堆排序 (Heap Sort) —— 必考大难点
*   **什么是堆？**
    *   **大根堆**：爸爸 $\ge$ 儿子 (根最大)。
    *   **小根堆**：爸爸 $\le$ 儿子 (根最小)。
    *   *物理存储*：用数组存，下标 $i$ 的左孩子是 $2i+1$，右孩子是 $2i+2$ (0开始)。

*   **核心动作：向下调整 (DownAdjust)**
    *   **场景**：如果我的两个儿子里有比我大的（大根堆），我就跟**最大的那个儿子**换位置。换下去之后，继续看新儿子的儿子... 直到我比儿子大，或者沉底。

*   **排序过程 (手推)**：
    1.  **建堆**：从**最后一个非叶子节点** ($\lfloor n/2 \rfloor - 1$) 开始，依次往前做 **DownAdjust**。
    2.  **排序**：
        *   把**堆顶** (最大值) 和 **堆底** (最后一个) 交换。
        *   把堆底 (刚换下来的最大值) **排除**出堆。
        *   对新的堆顶做 **DownAdjust**。
        *   重复，直到堆空。
*   **性能**：
    *   时间：$O(n \log n)$。
    *   空间：$O(1)$ (原地排序，不像快排要递归栈)。
    *   **不稳定**。

#### 3. 堆排序通俗理解
*   **物理结构**：数组。
*   **逻辑结构**：完全二叉树 (下标 $i$ 的孩子是 $2i+1$ 和 $2i+2$)。
*   **核心逻辑**：
    1.  **建堆 (整顿职场)**：从最后一个非叶子节点开始，往前挨个做“向下调整”，把大的数“浮”上去，小的数“沉”下来。
    2.  **排序 (裁员)**：
        *   把堆顶 (最大的) 和堆底 (最后的) 交换 -> 最大值归位。
        *   把剩下的堆顶 (刚才换上来的小兵) 做“向下调整”，选出第二大的。
        *   重复。
---

### 9.5 归并排序 (Merge Sort)
#### 1. 核心逻辑：分治 + 合并
*   **思想**：把两个**已经有序**的序列，合并成一个更大的有序序列。
*   **物理动作 (二路归并)**：
    *   就像有**两堆排好序的扑克牌**，牌面朝上。
    *   比较两堆最上面的牌，**谁小取谁**，放到新堆里。
    *   直到有一堆取完了，把另一堆剩下的直接摞上去。

#### 2. 考点分析
*   **空间复杂度 $O(n)$**：(死穴)
    *   这是所有高级排序里**最费内存**的。
    *   *原因*：因为它不能像快排那样在原地挪位置，它必须申请一个**和原数组一样大**的辅助数组 `B[]` 来暂存合并后的数据。
*   **稳定性**：**稳定**。
    *   (当左右两堆的牌一样大时，我们优先取左边那一堆的，所以相对顺序不变)。
*   **外部排序的基础**：
    *   如果文件太大（100GB），内存装不下，就必须用归并排序（把文件切碎，分别排好，再合并）。

---

### 9.6 基数排序 (Radix Sort) —— 唯一的异类
#### 1. 核心逻辑：不比较
*   所有的排序算法（快排、堆排等）都是靠**“比较”**（$A > B$ ?）。
*   基数排序是靠**“分配 + 收集”**（扔桶里）。

#### 2. 操作演示 (LSD - 最低位优先)
假设排：`520, 329, 100`
1.  **第一趟 (看个位)**：
    *   `520, 100` -> 扔进 0 号桶。
    *   `329` -> 扔进 9 号桶。
    *   **收集**：`520, 100, 329`。
2.  **第二趟 (看十位)**：
    *   `100` -> 0 号桶。
    *   `520, 329` -> 2 号桶。
    *   **收集**：`100, 520, 329`。
3.  **第三趟 (看百位)**：
    *   `100` -> 1 号桶。
    *   `329` -> 3 号桶。
    *   `520` -> 5 号桶。
    *   **收集**：`100, 329, 520` (有序了！)。

#### 3. 考点
*   **时间复杂度**：$O(d(n+r))$。
    *   $d$：趟数（最大数字有几位）。
    *   $n$：元素个数。
    *   $r$：桶的个数（十进制就是10）。
*   **稳定性**：**稳定** (必须稳定，否则高位排好后，低位的顺序就乱了)。

---

### 🛑 9.7 排序算法大总结 (考研背诵圣经)
**必考题：给表格填空。请务必抄在便利贴上背诵！**

| 算法 | 时间(平均) | 时间(最坏) | 空间 | 稳定性 | 特点一句话 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **直接插入** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **稳定** | **有序时最快** $O(n)$ |
| **希尔** | $O(n^{1.3})$ | $O(n^2)$ | $O(1)$ | 不稳 | 插入的改良版 |
| **冒泡** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **稳定** | 有序时也能 $O(n)$ |
| **快速** | **$O(n \log n)$** | **$O(n^2)$** | $O(\log n)$ | 不稳 | **综合性能之王**，最怕有序 |
| **简单选择** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳 | 比较次数固定 $n(n-1)/2$ |
| **堆排序** | **$O(n \log n)$** | **$O(n \log n)$** | **$O(1)$** | 不稳 | **空间最省**的高级排序 |
| **归并** | **$O(n \log n)$** | **$O(n \log n)$** | **$O(n)$** | **稳定** | **空间换时间**，外部排序用 |
| **基数** | $O(d(n+r))$ | - | $O(r)$ | **稳定** | 不比较 |

> **🔥 避坑/记忆口诀**：
> 1.  **谁不稳定？** **“快些选堆”** (心情不稳定，**快些选堆**朋友去玩)。
>     *   *快(速)、些(希尔)、选(择)、堆(排序)*。
> 2.  **谁时间复杂度好 ($N \log N$)？** **“快归堆”**。
> 3.  **谁最怕原本就有序？** **快排** (直接退化成 $O(N^2)$)。
> 4.  **谁和初始序列无关？**
>     *   **比较次数**无关：简单选择排序 (雷打不动比完)。
>     *   **排序时间**无关：归并排序 (怎么都要劈两半)。

### 9.8 外部排序 (External Sort)

#### 1. 核心流程
*   **场景**：文件太大，内存装不下。
*   **步骤**：
    1.  **生成初始归并段 (Run)**：把大文件切成很多小段，每段读入内存排好序，写回磁盘。
    2.  **多路归并**：把这些有序的小段，慢慢合并成一个大的有序文件。

#### 2. 败者树 (Loser Tree) —— 核心优化
*   **问题**：如果做 **k-路归并** (同时合并 k 个文件)，每次要从 k 个数里选最小的。
    *   普通方法：对比 $k-1$ 次。
    *   **败者树**：对比 $\lceil \log_2 k \rceil$ 次。
*   **原理**：
    *   一种特殊的**完全二叉树** (像体育比赛的晋级图)。
    *   **叶子**：选手 (待归并的元素)。
    *   **中间节点**：记录**输的人** (大的那个)。
    *   **冠军**：最终胜者 (最小的) 吐出来。
*   **优势**：当新的元素补进来时，不需要重新比 $k$ 次，只需要沿着树**往上比 log k 次**就行。

#### 3. 考点计算 (必考)
假设有 $r$ 个初始归并段，做 $k$ 路归并。
*   **归并趟数**：$S = \lceil \log_k r \rceil$。
*   **总 I/O 次数**：每次归并都要把所有数据读一遍写一遍。
    *   $I/O = 2 \times n \times (S + 1)$ (S是归并趟数，+1 是生成初始段的那次)。

#### 4. 置换-选择排序 (Replacement Selection)
*   **作用**：用来生成**更长**的初始归并段 (段越长，段数 $r$ 就越少，归并趟数就越少，I/O 就越少)。
*   **原理**：利用**堆 (Heap)**。类似流水线，进来一个比出去的大，就留着；比出去的小，就放到下一波。