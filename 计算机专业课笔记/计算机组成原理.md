- [第一章：数据的表示（定点数：原、反、补、移）](#第一章数据的表示定点数原反补移)
  - [1. 核心概念类比](#1-核心概念类比)
    - [1.1 原码 (Sign-Magnitude)：最符合直觉的“门牌号”](#11-原码-sign-magnitude最符合直觉的门牌号)
    - [1.2 补码 (Two's Complement)：计算机的“通用货币”](#12-补码-twos-complement计算机的通用货币)
    - [1.3 移码 (Excess Code)：浮点数的“阶码”专用](#13-移码-excess-code浮点数的阶码专用)
  - [2. 必考点与手把手转换（拿分关键）](#2-必考点与手把手转换拿分关键)
    - [2.1 转换口诀表 (背下来！)](#21-转换口诀表-背下来)
    - [2.2 演示：如果你在考场上遇到了 `-13`](#22-演示如果你在考场上遇到了--13)
  - [3. 408 挖坑点警示 (Tips)](#3-408-挖坑点警示-tips)
    - [坑点 1：表示范围（这题经常出选择题）](#坑点-1表示范围这题经常出选择题)
    - [坑点 2：符号扩展](#坑点-2符号扩展)
  - [核心考点：IEEE 754 浮点数（32位单精度）](#核心考点ieee-754-浮点数32位单精度)
    - [1. 为什么要有浮点数？](#1-为什么要有浮点数)
    - [2. 拼图结构（32位切分）](#2-拼图结构32位切分)
    - [3. 核心规则（必背，这里有坑！）](#3-核心规则必背这里有坑)
      - [坑点 1：阶码 E (Exponent) —— “移码”变体](#坑点-1阶码-e-exponent--移码变体)
      - [坑点 2：尾数 M (Mantissa) —— “隐藏的 1”](#坑点-2尾数-m-mantissa--隐藏的-1)
    - [4. 手把手计算演示（真题级难度）](#4-手把手计算演示真题级难度)
      - [第一步：转二进制](#第一步转二进制)
      - [第二步：规格化（变成科学计数法）](#第二步规格化变成科学计数法)
      - [第三步：计算三块拼图](#第三步计算三块拼图)
      - [第四步：拼装与十六进制转换](#第四步拼装与十六进制转换)
    - [5. 小抄总结 (64位双精度区别)](#5-小抄总结-64位双精度区别)
    - [6. 今日作业 (通关测试)](#6-今日作业-通关测试)
- [第二章：存储系统 (Memory Hierarchy)](#第二章存储系统-memory-hierarchy)
  - [1. 核心思想：局部性原理 (Principle of Locality)](#1-核心思想局部性原理-principle-of-locality)
  - [2. 存储器的层次结构 (The Pyramid)](#2-存储器的层次结构-the-pyramid)
  - [3. Cache 的核心工作原理 (重点考点)](#3-cache-的核心工作原理-重点考点)
    - [3.1 基本单位](#31-基本单位)
    - [3.2 核心问题：映射方式 (Mapping)](#32-核心问题映射方式-mapping)
      - [方式一：直接映射 (Direct Mapping)](#方式一直接映射-direct-mapping)
      - [方式二：全相联映射 (Fully Associative)](#方式二全相联映射-fully-associative)
      - [方式三：组相联映射 (Set Associative) —— **最常考**](#方式三组相联映射-set-associative--最常考)
  - [4. 手把手计算演示 (Cache 地址映射)](#4-手把手计算演示-cache-地址映射)
  - [5. 替换算法与写策略 (软件思维对接)](#5-替换算法与写策略-软件思维对接)
    - [5.1 替换算法 (Cache 满了踢谁走？)](#51-替换算法-cache-满了踢谁走)
    - [5.2 写策略 (如何保证 Cache 和内存一致？)](#52-写策略-如何保证-cache-和内存一致)
  - [6. 虚拟存储器 (Virtual Memory) - 简要版](#6-虚拟存储器-virtual-memory---简要版)
  - [章节总结 (End of Chapter 2)](#章节总结-end-of-chapter-2)
- [第三章：指令系统 (Instruction Set Architecture)](#第三章指令系统-instruction-set-architecture)
  - [1. 什么是指令？(Instruction)](#1-什么是指令instruction)
  - [2. 寻址方式 (Addressing Modes) —— **本章核心考点**](#2-寻址方式-addressing-modes--本章核心考点)
    - [2.1 立即寻址 (Immediate Addressing)](#21-立即寻址-immediate-addressing)
    - [2.2 直接寻址 (Direct Addressing)](#22-直接寻址-direct-addressing)
    - [2.3 间接寻址 (Indirect Addressing) —— 重点！](#23-间接寻址-indirect-addressing--重点)
    - [2.4 寄存器寻址 (Register Addressing)](#24-寄存器寻址-register-addressing)
    - [2.5 基址/变址寻址 (Base/Index Addressing) —— 数组与OS的基础](#25-基址变址寻址-baseindex-addressing--数组与os的基础)
    - [2.6 相对寻址 (PC-Relative) —— `if-else` 的基础](#26-相对寻址-pc-relative--if-else-的基础)
  - [3. CISC vs RISC (世纪大战)](#3-cisc-vs-risc-世纪大战)
  - [4. 必考计算题模型：寻址过程推导](#4-必考计算题模型寻址过程推导)
  - [5. 小抄总结 (Chapter 3)](#5-小抄总结-chapter-3)
  - [今日作业 (寻址逻辑测试)](#今日作业-寻址逻辑测试)
    - [重新详解：寻址过程推导（特别是“相对寻址”的坑）](#重新详解寻址过程推导特别是相对寻址的坑)
      - [1. 核心矛盾：PC 到底指在哪里？](#1-核心矛盾pc-到底指在哪里)
      - [2. 手把手推导：相对寻址 (PC-Relative)](#2-手把手推导相对寻址-pc-relative)
    - [3. 三大“加法类”寻址方式对比](#3-三大加法类寻址方式对比)
    - [第一题：相对寻址的“时空陷阱”](#第一题相对寻址的时空陷阱)
    - [第二题：基址 vs 变址 (谁动了我的奶酪？)](#第二题基址-vs-变址-谁动了我的奶酪)
    - [第三题：综合寻址侦探](#第三题综合寻址侦探)
    - [架构师解析 (你掉坑里了吗？)](#架构师解析-你掉坑里了吗)
      - [第一题解析：相对寻址 (负数回跳)](#第一题解析相对寻址-负数回跳)
      - [第二题解析：基址 vs 变址](#第二题解析基址-vs-变址)
      - [第三题解析：综合侦探](#第三题解析综合侦探)
- [第四章：总线与 I/O —— 计算机的“物流系统”](#第四章总线与-io--计算机的物流系统)
  - [1. 总线 (The Bus)：计算机的高速公路](#1-总线-the-bus计算机的高速公路)
    - [1.1 什么是总线？](#11-什么是总线)
    - [1.2 总线的三大车道 (必考)](#12-总线的三大车道-必考)
    - [1.3 核心计算：总线带宽 (Bandwidth)](#13-核心计算总线带宽-bandwidth)
  - [2. I/O 控制方式的演变 (The Evolution of Laziness)](#2-io-控制方式的演变-the-evolution-of-laziness)
    - [阶段 1：程序查询方式 (Polling) —— 累死 CEO](#阶段-1程序查询方式-polling--累死-ceo)
    - [阶段 2：中断驱动方式 (Interrupt) —— CEO 的电话响了](#阶段-2中断驱动方式-interrupt--ceo-的电话响了)
    - [阶段 3：DMA 方式 (Direct Memory Access) —— 请个搬运工](#阶段-3dma-方式-direct-memory-access--请个搬运工)
  - [3. 深入理解：中断 (Interrupt) 的全过程](#3-深入理解中断-interrupt-的全过程)
  - [4. 易混概念：中断 vs DMA](#4-易混概念中断-vs-dma)
  - [5. 今日作业 (总线与 I/O)](#5-今日作业-总线与-io)
- [第五章：中央处理器 (The CPU)](#第五章中央处理器-the-cpu)
  - [1. 拆解 CPU：只有两个部门](#1-拆解-cpu只有两个部门)
  - [2. 核心寄存器：CPU 的“贴身口袋” (必背)](#2-核心寄存器cpu-的贴身口袋-必背)
    - [2.1 用户可见寄存器 (程序员能用的)](#21-用户可见寄存器-程序员能用的)
    - [2.2 用户不可见寄存器 (硬件偷偷用的)](#22-用户不可见寄存器-硬件偷偷用的)
  - [3. 指令执行的微观流程 (The Heartbeat)](#3-指令执行的微观流程-the-heartbeat)
  - [4. 控制器的两种设计 (硬布线 vs 微程序)](#4-控制器的两种设计-硬布线-vs-微程序)
    - [4.1 硬布线控制器 (Hardwired)](#41-硬布线控制器-hardwired)
    - [4.2 微程序控制器 (Microprogrammed) —— **重点**](#42-微程序控制器-microprogrammed--重点)
  - [5. 指令流水线 (Pipelining) —— **计算题得分王**](#5-指令流水线-pipelining--计算题得分王)
    - [5.1 概念类比：洗衣服](#51-概念类比洗衣服)
    - [5.2 性能计算公式](#52-性能计算公式)
    - [5.3 坑点：流水线冒险 (Hazards) —— 为什么流水线会卡住？](#53-坑点流水线冒险-hazards--为什么流水线会卡住)
  - [6. 终极实战：数据通路的大题逻辑](#6-终极实战数据通路的大题逻辑)
  - [7. 今日作业 (CPU 毕业考)](#7-今日作业-cpu-毕业考)

# 第一章：数据的表示（定点数：原、反、补、移）

作为程序员，你定义一个 `int a = -5;`，在内存里它绝不是写着 "-5" 两个字符，而是一串 `1` 和 `0`。
**这一章的核心任务就是：如何用 0 和 1 完美地表示正负数，并且让计算机能方便地做加减法。**

## 1. 核心概念类比

为了让计算机这个“笨蛋”能只用加法器就搞定减法，人类发明了不同的编码方式。

### 1.1 原码 (Sign-Magnitude)：最符合直觉的“门牌号”
*   **软件视角**：带符号的绝对值。
*   **规则**：最高位是**符号位**（0正 1负），剩下是**数值位**。
*   **例子**（以8位二进制为例）：
    *   `+5` -> **0**000 0101
    *   `-5` -> **1**000 0101
*   **缺点**：
    1.  **0 有两个**：`+0` (00000000) 和 `-0` (10000000)。浪费！
    2.  **计算反人类**：计算机做 `-5 + 5` 时，如果直接按位相加，结果是 `10001010` (-10)，错得离谱。这意味着还要专门设计减法电路，太贵！

### 1.2 补码 (Two's Complement)：计算机的“通用货币”
*   **地位**：**408 考试中的绝对霸主**。现代计算机里，整数都是存补码。
*   **软件思维**：模运算（Mod）。
*   **生活类比（时钟魔法）**：
    *   现在是 10 点，你想回到 8 点（做减法 10 - 2）。
    *   方法一：倒拨 2 格（减法）。
    *   方法二：顺拨 10 格（加法）。10 + 10 = 20，时钟只有 12 个刻度，20 Mod 12 = 8。
    *   **结论**：**减去一个数 = 加上这个数的同余数（补数）**。补码就是利用这个原理，**把减法变成了加法**。

### 1.3 移码 (Excess Code)：浮点数的“阶码”专用
*   **用途**：专门用来表示浮点数的“指数部分”（比如 $1.5 \times 2^{-3}$ 中的 -3）。
*   **特点**：为了方便比大小。把负数整体“平移”到正数区间，这样一眼就能看出谁大谁小，不用管符号位。

---

## 2. 必考点与手把手转换（拿分关键）

考试通常会给你一个**真值**（人类看到的数，如 -19），让你转成各种码；或者反过来。
**默认假设字长为 8 位（1位符号，7位数值）。**

### 2.1 转换口诀表 (背下来！)

| 转换方向 | 正数 (符号位=0) | 负数 (符号位=1) | 记忆口诀 |
| :--- | :--- | :--- | :--- |
| **真值 -> 原码** | 符号位0，数值转二进制 | 符号位1，数值转二进制 | 直接写 |
| **原码 -> 反码** | 没变化 | 符号位不变，**数值位按位取反** | 正同负反 |
| **原码 -> 补码** | 没变化 | 符号位不变，**数值位取反，末位+1** | **取反加一** |
| **补码 -> 原码** | 没变化 | 符号位不变，**数值位取反，末位+1** | **还是取反加一** (逆运算逻辑一样) |
| **补码 -> 移码** | **符号位取反**，数值位不变 | **符号位取反**，数值位不变 | **补码变移码，只把头变反** |

### 2.2 演示：如果你在考场上遇到了 `-13`

**步骤 1：先写出原码**
*   13 的二进制是 `1101`。
*   补齐 8 位（1位符号，7位数值）：`0000 1101`。
*   因为是负数，符号位变 1：
*   **原码** = `1000 1101`

**步骤 2：求反码（中间状态，一般不考，但必须会）**
*   符号位 `1` 不动。
*   后面 `000 1101` 全部反过来 -> `111 0010`。
*   **反码** = `1111 0010`

**步骤 3：求补码（重中之重）**
*   在反码的基础上，末位 + 1。
*   `1111 0010` + `1` = `1111 0011`。
*   **补码** = `1111 0011`
    *   *(快速验证：-13。13=8+4+1。补码里，符号位是 -128 权重。 -128 + 64 + 32 + 16 + 08 +0*4 + 2 + 1... 这种方式太慢。主要记取反加一)*

**步骤 4：求移码**
*   拿着补码 `1111 0011`。
*   把打头的 `1` 改成 `0`。
*   **移码** = `0111 0011`

---

## 3. 408 挖坑点警示 (Tips)

### 坑点 1：表示范围（这题经常出选择题）
为什么补码比原码能多存一个数？
*   **原码**：`10000000` 是 -0，`00000000` 是 +0。这就浪费了。
*   **补码**：`00000000` 就是 0。而 `10000000` 既然没有 -0 的概念，就被规定为 **-128**。
*   **结论 (8位为例)**：
    *   原码范围：-127 ~ +127
    *   **补码范围：-128 ~ +127** (注意那个多出来的负数！)

### 坑点 2：符号扩展
*   **场景**：如果你把一个 8 位的数（`short`）强转成 16 位（`int`），系统怎么填多出来的 8 位？
*   **正数**：前面全补 0。
*   **负数 (补码)**：**前面全补 1**。（为了保持值不变）
    *   例：8位 -5 (`1111 1011`) -> 16位 -5 (`1111 1111 1111 1011`)。

---

## 核心考点：IEEE 754 浮点数（32位单精度）

### 1. 为什么要有浮点数？
**软件思维**：
如果我们要存一个很大的数（比如太阳的质量）或者很小的数（原子的半径），用整数（定点数）不够用。
**类比**：
这就是数学里的**科学计数法**。
*   十进制：$-1.23 \times 10^4$
*   二进制：$-1.01 \times 2^5$

计算机为了存这个“科学计数法”，设计了一个**32个格子的盒子**（32位，对应 Java 的 `float`）。

### 2. 拼图结构（32位切分）

一定要把这张图刻在脑子里！我们将 32 位切分成**三段**：

| 顺序 | 名称 | 长度 | 作用 | 类比 (科学计数法 $\pm M \times 2^E$) |
| :--- | :--- | :--- | :--- | :--- |
| **1** | **数符 (S)** | 1位 | 决定正负 | 公式的 $\pm$ 号 |
| **2** | **阶码 (E)** | 8位 | 决定小数点移几位 | 公式的指数 $E$ (10的几次方) |
| **3** | **尾数 (M)** | 23位 | 决定精度（有效数字） | 公式的 $M$ (1.23 那部分) |

---

### 3. 核心规则（必背，这里有坑！）

#### 坑点 1：阶码 E (Exponent) —— “移码”变体
为了避免在指数里还要处理正负号（比如 $2^{-3}$），IEEE 754 规定：**存进去的指数，必须加上一个偏移量（Bias）。**
*   **32位浮点数的偏移量是 127**。
*   **公式**：`存入机器的 E` = `真实指数` + `127`
*   *类比：为了不让温度计出现负数，我们把 0 度刻度标为 127。这样 -10 度就变成了 117，全是正数，方便比较。*

#### 坑点 2：尾数 M (Mantissa) —— “隐藏的 1”
在二进制科学计数法中（例如 $1.011 \times 2^3$），因为二进制非 0 即 1，只要这个数不是 0，**小数点左边永远是 1**。
*   既然永远是 1，**那我就不存它了，省一位空间！**
*   **存储时**：只存小数点**后面**的部分。
*   **读取时**：自动在前面补上 `1.`。

---

### 4. 手把手计算演示（真题级难度）

**任务：将十进制数 `-26.625` 转换为 IEEE 754 标准（32位），并用十六进制表示。**

请跟着我的步骤走，一步都不要跳。

#### 第一步：转二进制
*   **整数部分**：26
    *   $26 = 16 + 8 + 2$ -> `11010`
*   **小数部分**：0.625
    *   $0.625 \times 2 = 1.25$ (取整 1)
    *   $0.25 \times 2 = 0.5$ (取整 0)
    *   $0.5 \times 2 = 1.0$ (取整 1)
    *   -> `.101`
*   **合并**：`-11010.101`

#### 第二步：规格化（变成科学计数法）
我们要把小数点左移，直到只剩下一位整数（而且必须是 1）。
*   `11010.101` 左移 4 位 -> $1.1010101 \times 2^4$
*   这里我们得到了两个关键数据：
    *   **真实指数** = 4
    *   **有效尾数** = 1.1010101

#### 第三步：计算三块拼图

**1. 数符 (S)**
*   因为是负数，所以 **S = 1**。

**2. 阶码 (E)**
*   **公式**：真实指数 + 127
*   $4 + 127 = 131$
*   把 131 转成 8 位二进制：$131 = 128 + 3$ -> **1000 0011**

**3. 尾数 (M)**
*   把第二步里的 $1.1010101$ 小数点前面的 `1` 扔掉（隐藏位）。
*   剩下 `1010101`。
*   因为尾数有 23 位，**后面要补够 0**。
*   **M** = **1010 1010 0000 0000 0000 000**

#### 第四步：拼装与十六进制转换

把它们连起来：
`1` (S) `10000011` (E) `10101010000000000000000` (M)

**二进制流**：
`1100 0001 1101 0101 0000 0000 0000 0000`

**转十六进制 (每4位一组)**：
*   `1100` -> **C**
*   `0001` -> **1**
*   `1101` -> **D**
*   `0101` -> **5**
*   `0000` -> **0** ...

**最终答案**：`C1D50000`H

---

### 5. 小抄总结 (64位双精度区别)

考试虽然主要考 32 位（float），但偶尔会问 64 位（double）。只需要记住区别：

| 特性 | float (32位) | double (64位) |
| :--- | :--- | :--- |
| 阶码 E 长度 | 8位 | **11位** |
| 尾数 M 长度 | 23位 | **52位** |
| **偏移量 Bias** | 127 | **1023** |

**记忆口诀**：
*   32位：符号1，阶码8，尾数23，偏127。
*   64位：符号1，阶码11，尾数52，偏1023。

---

### 6. 今日作业 (通关测试)

请在纸上计算：
将十进制数 **+19.5** 转换为 32 位浮点数的 **十六进制** 表示。

**(提示流程：转二进制 -> 找指数 -> 加127 -> 去掉首位1 -> 拼装)**

<br>
<br>
<br>

**参考答案**（做完再看！）：
1.  **二进制**：19.5 = `10011.1`
2.  **规格化**：$1.00111 \times 2^4$ (指数是 4)
3.  **S**：0 (正数)
4.  **E**：4 + 127 = 131 -> `1000 0011`
5.  **M**：去掉首位 1，剩 `00111`，后面补0 -> `0011 1000 ...`
6.  **拼装**：`0` `10000011` `00111000...`
7.  **整理**：`0100 0001 1001 1100 ...`
8.  **十六进制**：`419C0000`H

---

# 第二章：存储系统 (Memory Hierarchy)

## 1. 核心思想：局部性原理 (Principle of Locality)

这是整个存储体系存在的基石。如果程序没有局部性，Cache 就毫无意义。

*   **软件视角**：
    *   你写的 `for` 循环为什么快？
    *   数组遍历为什么比链表遍历快？
*   **两大分类**：
    1.  **时间局部性 (Temporal Locality)**：
        *   **定义**：如果一个数据被访问了，不久之后它很可能再次被访问。
        *   **代码例子**：循环变量 `i`，循环体内的指令。
    2.  **空间局部性 (Spatial Locality)**：
        *   **定义**：如果一个数据被访问了，它**附近**的数据很可能马上被访问。
        *   **代码例子**：数组 `arr[0]` 被访问后，`arr[1]` 极大概率会被访问。

> **硬件推论**：基于空间局部性，Cache 从内存拿数据时，**绝不会只拿一个字节，而是一次搬运一整块（Block/Line）**。

---

## 2. 存储器的层次结构 (The Pyramid)

为了解决 **“CPU 太快，硬盘太慢”** 的矛盾，计算机采用了多级缓存策略。

| 层级 | 硬件位置 | 速度 | 容量 | 价格 | 软件类比 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **寄存器 (Register)** | CPU 内部 | 最快 (ns级) | 极小 | 极贵 | 手里的便签 |
| **Cache (L1/L2/L3)** | CPU 内部/旁路 | 很快 | 小 (MB级) | 贵 | **办公桌** |
| **主存 (RAM)** | 内存条 | 中等 | 中 (GB级) | 适中 | **书架** |
| **辅存 (Disk)** | 硬盘 | 极慢 (ms级) | 极大 (TB级) | 便宜 | **图书馆仓库** |

---

## 3. Cache 的核心工作原理 (重点考点)

### 3.1 基本单位
*   **块 (Block) / 行 (Line)**：Cache 和主存交换数据的最小单位。
    *   *注意：408 题目中常混用“块”和“行”，默认它们是一回事。*
*   **命中 (Hit)**：CPU 要的数据在 Cache 里。
*   **缺失 (Miss)**：CPU 要的数据不在 Cache 里，要去内存拿（会有时间惩罚）。

### 3.2 核心问题：映射方式 (Mapping)
这是本章计算题的**重灾区**。
**场景**：内存（大旅馆）有 1000 个房间，Cache（小公寓）只有 10 个房间。内存的第 55 号房间的内容，应该搬到 Cache 的哪个房间？

#### 方式一：直接映射 (Direct Mapping)
*   **规则**：**取模运算**。`Cache行号 = 内存块号 % Cache总行数`
*   **类比**：你学号尾号是 5，你就只能坐第 5 排。
*   **优点**：电路简单，找得快（不用一个个比对）。
*   **缺点**：冲突率极高（如果反复访问第 5 号和第 15 号内存块，它俩会打架，反复踢出对方）。
*   **地址结构**：
    `[ 标记 (Tag) ] [ 行索引 (Index) ] [ 块内偏移 (Offset) ]`

#### 方式二：全相联映射 (Fully Associative)
*   **规则**：**随便坐**。内存块可以放在 Cache 的任意位置。
*   **类比**：进了教室随便坐，哪里有空位坐哪里。
*   **优点**：冲突率低，空间利用率高。
*   **缺点**：找东西太慢（硬件要并发比较所有 Cache 行的 Tag，电路复杂且昂贵）。
*   **地址结构**：
    `[ 标记 (Tag) ] [ 块内偏移 (Offset) ]` (没有 Index，因为不需要定位行)

#### 方式三：组相联映射 (Set Associative) —— **最常考**
*   **规则**：**先分组，组内随便坐**。
*   **例如**：2 路组相联（2-way Set Associative）= 两个房间编成一组。
*   **算法**：`组号 = 内存块号 % 组数`。算出组号后，该组内的 2 个位置随便放。
*   **类比**：你被分配到“第 3 组”，但第 3 组里有两个座位，你爱坐左边还是右边都行。
*   **地位**：这是前两种的折中方案，现代 CPU 大多采用这种。
*   **地址结构**：
    `[ 标记 (Tag) ] [ 组索引 (Set Index) ] [ 块内偏移 (Offset) ]`

---

## 4. 手把手计算演示 (Cache 地址映射)

**典型真题模型**：
> 假设主存大小 4GB，Cache 大小 16KB，块大小 (Block Size) 64B。
> 采用 **2路组相联** 映射。
> 请问：物理地址如何切分？（求 Tag、Index、Offset 的位数）

**解题步骤 (逻辑链)**：

1.  **确定物理地址总长度**：
    *   主存 4GB = $2^{32}$ Bytes。
    *   所以物理地址总共 **32 位**。

2.  **确定块内偏移 (Offset)**：
    *   块大小 64B = $2^6$。
    *   所以在块里找字节需要 **6 位**。
    *   **(Offset = 6)**

3.  **确定 Cache 的总行数和组数**：
    *   Cache 总大小 16KB = $16 \times 1024 = 2^{14}$ Bytes。
    *   块大小 = 64B = $2^6$。
    *   总行数 = $2^{14} / 2^6 = 2^8 = 256$ 行。
    *   **关键点**：因为是 **2路** 组相联，所以 2 行是一组。
    *   组数 = $256 / 2 = 128$ 组 = $2^7$。
    *   所以组索引需要 **7 位**。
    *   **(Index/Set = 7)**

4.  **确定标记位 (Tag)**：
    *   剩下的都是 Tag。
    *   Tag = 总长度 - 组索引 - 块内偏移
    *   Tag = 32 - 7 - 6 = **19 位**。

**最终答案**：Tag(19位) | Index(7位) | Offset(6位)

---

## 5. 替换算法与写策略 (软件思维对接)

### 5.1 替换算法 (Cache 满了踢谁走？)
*   **RAND (随机)**：瞎选。性能差。
*   **FIFO (先进先出)**：谁先来谁滚蛋。不科学（可能有个老数据也是热点数据）。
*   **LRU (Least Recently Used, 最近最少使用)**：**必考**。
    *   **软件类比**：Java 的 `LinkedHashMap(accessOrder=true)`。
    *   **规则**：把最近访问的提到队头，淘汰队尾那个最久没动过的。
    *   **硬件实现**：通常需要几位“计数位”。

### 5.2 写策略 (如何保证 Cache 和内存一致？)
当你修改了 Cache 里的变量 `a = 100`，内存里还是 `a = 0`，怎么办？

1.  **全写法 (Write Through)**：
    *   **动作**：写 Cache 的同时，立马写内存。
    *   **优点**：简单，数据绝对一致。
    *   **缺点**：慢！每次写操作都卡在写内存上。
2.  **回写法 (Write Back)** —— **现代主流**
    *   **动作**：只修改 Cache，不理内存。只有当这块数据**被踢出 (Evict)** Cache 时，才写回内存。
    *   **关键技术**：**脏位 (Dirty Bit)**。如果这个位是 1，说明数据被改过，踢出时必须写回；如果是 0，说明没改过，直接丢弃即可（省一次 IO）。
    *   **软件类比**：数据库的 Buffer Pool。你 Update 一条记录，通常是先改内存，定期刷盘。

---

## 6. 虚拟存储器 (Virtual Memory) - 简要版
*这部分在操作系统会详讲，组成原理主要考硬件实现（TLB）。*

*   **TLB (Translation Lookaside Buffer)**：
    *   **别名**：快表。
    *   **本质**：**页表 (Page Table)** 的 Cache。
    *   **功能**：加速 `虚拟地址 -> 物理地址` 的转换。
    *   **考点逻辑**：CPU 拿虚拟地址 -> 查 TLB -> (若 Miss) 查 Page Table (在内存) -> 得到物理地址 -> 查 Cache -> (若 Miss) 查主存。

---

## 章节总结 (End of Chapter 2)

对于软件开发背景的考生，**存储系统**是最容易拿分也最容易理解的章节。

**记忆清单**：
1.  **局部性原理**是老祖宗。
2.  **Cache 映射计算**（直接、全相联、组相联）必须会算 Tag/Index/Offset 的位数。
3.  **Write Back** 策略需要 **Dirty Bit**。
4.  **TLB** 是页表的缓存。

---

# 第三章：指令系统 (Instruction Set Architecture)

## 1. 什么是指令？(Instruction)

**软件视角**：
你写一句 `c = a + b;`，在 CPU 看来，这是让它干活的“圣旨”。
但这道“圣旨”不能这么写，因为 CPU 听不懂变量名。它只认识**寄存器**和**内存地址**。

**硬件视角（指令格式）**：
一条指令通常长这样：
`[ 操作码 (OpCode) ] [ 地址码 (Address Fields) ]`

*   **操作码 (OpCode)**：干什么？(例如：`ADD`, `MOV`, `JMP`)
*   **地址码 (Address)**：对谁干？(例如：`R1` 寄存器，或者内存 `0x1000` 号单元)

---

## 2. 寻址方式 (Addressing Modes) —— **本章核心考点**

这是 408 考试中**必考**的内容，也是程序员最容易理解偏差的地方。
**核心问题**：指令里给出的那个“数字”，到底是什么？是数据本身？是地址？还是地址的地址？

我们用 **“寻宝游戏”** 来类比。假设指令里的**形式地址**叫 `A`。我们要找的**真实数据**叫 `EA` (Effective Address)。

### 2.1 立即寻址 (Immediate Addressing)
*   **指令内容**：`LOAD #100`
*   **含义**：`A` 就是数据本身。
*   **C语言**：`int a = 100;`
*   **特点**：极快（不用查内存），但数的大小受限于指令长度。

### 2.2 直接寻址 (Direct Addressing)
*   **指令内容**：`LOAD [100]`
*   **含义**：`A` 是内存地址。去 100 号房间拿数据。
*   **C语言**：全局变量。
*   **特点**：简单，但地址位数有限，访问范围受限。

### 2.3 间接寻址 (Indirect Addressing) —— 重点！
*   **指令内容**：`LOAD @[100]` (符号因汇编风格而异)
*   **含义**：`A` 是地址。去 100 号房间，里面放着**另一个地址**（比如 200），再去 200 号房间拿数据。
*   **C语言**：**指针** `int *p = &x; int a = *p;`
*   **特点**：虽然慢（查两次内存），但这让程序能灵活操作地址，是“指针”的硬件基石。

### 2.4 寄存器寻址 (Register Addressing)
*   **指令内容**：`ADD R1, R2`
*   **含义**：数据在 CPU 的寄存器里。
*   **C语言**：`register int i` (或者编译器优化后的局部变量)。
*   **特点**：**最快**（完全不需要出 CPU 找内存）。

### 2.5 基址/变址寻址 (Base/Index Addressing) —— 数组与OS的基础
*   **指令内容**：`LOAD R1, 100` (假设 R1 里存了 2000)
*   **含义**：真实地址 = `R1的内容` + `100` = 2100。
*   **场景 1 (基址)**：**操作系统重定位**。程序被加载到内存的哪里不知道，把起始地址存在基址寄存器里，程序里的偏移量不用改。
*   **场景 2 (变址)**：**数组访问**。
    *   `arr[i]`：数组首地址是固定的，`i` 在变。
    *   硬件逻辑：`首地址 + i * 4`。

### 2.6 相对寻址 (PC-Relative) —— `if-else` 的基础
*   **含义**：相对于**当前指令的位置 (PC)** 跳跃多少。
*   **场景**：`for` 循环、`if` 跳转。
*   **关键点**：它保证了代码在内存里挪窝之后（浮动代码），跳转依然正确（因为相对距离没变）。

---

## 3. CISC vs RISC (世纪大战)

这是选择题常客。虽然现在的 CPU 都在互相学习，但考试时要**二元对立**地看。

| 特性 | CISC (复杂指令集) | RISC (精简指令集) |
| :--- | :--- | :--- |
| **代表选手** | **Intel x86** (你的 PC) | **ARM** (你的手机/M1 Mac) |
| **指令设计** | **像瑞士军刀**。一条指令能干很多事（如：从内存取数+计算+写回）。 | **像积木**。一条指令只干一件事（要么取数，要么算）。 |
| **指令长度** | **不固定** (长长短短) | **固定** (整齐划一) |
| **硬件复杂度**| 极高 (微程序控制) | 简单 (硬布线控制) |
| **软件编译器**| 编译器轻松，代码短。 | 编译器累死，代码长。 |
| **执行速度** | 2/8 原则：20% 的指令最常用。 | **流水线技术**极其发达 (跑得快)。 |

**一句话总结**：
*   **CISC**：硬件是保姆，软件省心。（适合早期内存贵的时代）
*   **RISC**：硬件是流水线工人，软件（编译器）是工头。（适合现代追求高性能的时代）

---

## 4. 必考计算题模型：寻址过程推导

这种题目通常会画一张图或者给一组数据，让你算**EA (有效地址)** 和 **操作数 (Operand)**。

**[经典例题]**
CPU 状态如下：
*   程序计数器 (PC) = `2000H`
*   变址寄存器 (X) = `0030H`
*   内存 `2000H` 处的内容（指令）= `指令操作码 | 寻址特征 | 形式地址D`
    *   假设指令长度 4 字节。
    *   形式地址 D = `0020H`。

**问：若采用“相对寻址”，有效地址 EA 是多少？**

**解题手把手**：
1.  **理解 PC**：PC 永远指向**下一条**即将执行的指令。
    *   当前指令在 `2000H`，长度 4 字节。
    *   取指完成后，PC 自动加 4 -> **PC = 2004H**。（**这是最大的坑，一定要先加 PC**）
2.  **相对寻址公式**：`EA = (PC) + D`
    *   注意：这里的 (PC) 指的是**更新后**的 PC。
3.  **计算**：
    *   $EA = 2004H + 0020H = 2024H$。
4.  **结论**：操作数在内存 `2024H` 处。

---

## 5. 小抄总结 (Chapter 3)

1.  **指令 = 操作码 + 地址码**。
2.  **寻址方式口诀**：
    *   立即：数在指令里。
    *   直接：数在内存里（地址固定）。
    *   间接：是指针（地址的地址）。
    *   寄存器：在 CPU 肚子里（最快）。
    *   相对：以当前 PC 为基准跳（注意 PC 自动 +1/指令长度）。
3.  **CISC vs RISC**：
    *   x86 是 CISC，不定长，复杂。
    *   ARM 是 RISC，定长，简单，流水线好。

---

## 今日作业 (寻址逻辑测试)

这是一道**逻辑侦探题**，做对了这个，你的寻址方式就没问题了。

**题目背景**：
*   寄存器 R1 = `1000H`
*   内存 `1000H` 单元的内容 = `2000H`
*   内存 `2000H` 单元的内容 = `3000H`
*   指令形式地址 D = `1000H`

**请分别写出以下寻址方式中，CPU 最终拿到的“数据”是多少？**
1.  **立即寻址**：数据 = ?
2.  **直接寻址**：数据 = ?
3.  **间接寻址** (一次间接)：数据 = ?
4.  **寄存器间接寻址** (以 R1 为寄存器)：数据 = ?

*(提示：分清“地址”和“地址里的内容”)*

<br>
<br>
<br>

**参考答案**：
1.  **立即寻址**：指令里的 D 就是数据。 -> **1000H**
2.  **直接寻址**：去 D (`1000H`) 指向的内存找。-> 内存[`1000H`] -> **2000H**
3.  **间接寻址**：去 D (`1000H`) 找地址，得到 `2000H`；再去 `2000H` 找数据。-> 内存[`2000H`] -> **3000H**
4.  **寄存器间接寻址**：去 R1 里面存的地址 (`1000H`) 找数据。-> 内存[`1000H`] -> **2000H**

---

### 重新详解：寻址过程推导（特别是“相对寻址”的坑）

你在“相对寻址”那里卡住，通常是因为**忽略了 CPU 的“隐形动作”**。

我们要引入一个微观概念：**指令周期（Instruction Cycle）**。
CPU 执行一条指令，不是“瞬间”完成的，而是分步走的。

#### 1. 核心矛盾：PC 到底指在哪里？

*   **PC (Program Counter)** 的定义：永远指向 **“下一条”** 要取出的指令地址。
*   **关键动作**：**取指（Fetch）**。
    *   当 CPU 刚把当前指令从内存里拿出来，还没开始分析这指令是干嘛的时候，**PC 就已经自动加 1（或者加指令长度）了**。
    *   **为什么？** 为了给下一条指令做准备。CPU 是个急性子。

#### 2. 手把手推导：相对寻址 (PC-Relative)

**场景设定**：
*   **当前指令地址**：`2000H`
*   **指令长度**：`4` 字节 (这意味着下一条指令在 `2004H`)
*   **指令内容**：`JMP +20H` (相对跳转 20H)

**慢动作回放**：

| 时间点 | 动作 (CPU 内部发生了什么) | PC 的值 | 备注 |
| :--- | :--- | :--- | :--- |
| **T0** | CPU 准备取指，PC 指向当前指令。 | **2000H** | 此时还没动。 |
| **T1** | **取指 (Fetch)**。CPU 读入 `2000H` 处的内容。 | **2000H** | 正在读... |
| **T2** | **自动更新 PC**。**这是最关键的一步！** | **2004H** | 读完瞬间，PC 自动指向下一条了。 |
| **T3** | **执行 (Execute)**。CPU 分析指令发现是“相对跳转 +20H”。 | 2004H | 此时基准已经是 2004 了。 |
| **T4** | **计算目标地址 (EA)**。 | 2004H | EA = (现在的PC) + 偏移量 |
| **结果** | EA = 2004H + 20H = **2024H** | **2024H** | 跳转落地。 |

**类比：寻宝游戏**
*   你站在 `2000` 号石板上。
*   你捡起脚下的纸条（指令）。
*   **当你读纸条的时候，你的身体已经习惯性地往前迈了一步，站在了 `2004` 号石板上。**
*   纸条上写着：“从你**现在站的地方**往前走 20 米”。
*   所以你的终点是：`2004` + `20` = `2024`。
*   如果你用 `2000` + `20`，就掉坑里了。

---

### 3. 三大“加法类”寻址方式对比

考试最喜欢把这三个混在一起考，一定要分清**谁加上谁**。

假设：
*   **PC** = 程序计数器
*   **X / IX** = 变址寄存器 (Index Register) —— 对应数组索引 `i`
*   **BR / RB** = 基址寄存器 (Base Register) —— 对应程序起始位置
*   **D / A** = 指令里写的形式地址（偏移量）

| 寻址方式 | 公式 (EA = ?) | 谁在变？ | 谁不变？ | 典型用途 |
| :--- | :--- | :--- | :--- | :--- |
| **相对寻址** | **(PC) + D** | PC (随程序跑) | D (指令写死的) | `if-else`, `for` 跳转, 浮动代码 |
| **变址寻址** | **(X) + D** | X (程序员改 `i`) | D (数组首地址) | **数组遍历** (面向用户) |
| **基址寻址** | **(BR) + D** | D (指令写死的) | BR (OS 定死的) | **程序重定位** (面向操作系统) |

**硬核考点区别 (基址 vs 变址)**：
*   **基址 (Base)**：是**操作系统**管的。你写的程序里，偏移量 D 是固定的。操作系统把你把整个程序搬到内存另一个角落，只需改 BR，你的程序不用重编译。
*   **变址 (Index)**：是**程序员**管的。你要遍历数组，是你自己在汇编里写 `INC X` (让 X 加 1)。

---
、

### 第一题：相对寻址的“时空陷阱”
**背景**：
CPU 正在执行一段程序。
*   当前指令存放地址：`PC = 2000H` (十六进制)
*   当前指令长度：`2` 字节 (注意！不是 4 了)
*   指令内容是：`JNZ E0H` (JNZ 是条件跳转指令，`E0H` 是形式地址/偏移量)
*   假设：这里偏移量 `E0H` 是一个 **8位补码**。

**问题**：
如果跳转成功，下一条指令的地址 (EA) 是多少？
*(提示：8位补码 E0H 代表负数还是正数？先转成十进制看看？)*

---

### 第二题：基址 vs 变址 (谁动了我的奶酪？)
**背景**：
你正在编写一个用于 **计算数组总和** 的循环程序。
系统有两个专用寄存器：
*   `BR` (Base Register，基址寄存器)
*   `IX` (Index Register，变址寄存器)

**问题**：
在指令 `ADD R1, (Reg) + Offset` 中：
1.  如果要访问数组中的第 `i` 个元素（`Offset` 代表数组首地址），`Reg` 应该选 `BR` 还是 `IX`？
2.  如果在多道程序并发环境下，操作系统将你的程序从内存 A 处 搬移到了 内存 B 处，操作系统只需要修改 `BR` 还是 `IX` 的值？

---

### 第三题：综合寻址侦探
**背景 (内存快照)**：
*   CPU 寄存器 `R1 = 0200H`
*   内存 `0200H` 单元内容 = `0300H`
*   内存 `0300H` 单元内容 = `0400H`
*   内存 `0400H` 单元内容 = `0500H`
*   内存 `0500H` 单元内容 = `0600H`

**指令**：`LOAD R0, (由以下方式决定)`
形式地址 **D = 0200H**。

**问题**：
请写出以下三种方式最后取到 R0 里的 **“数据值”** (不是地址) 是多少？
1.  **寄存器间接寻址 (R1)**：
    *   提示：EA = (R1)
2.  **变址寻址 (R1)**：
    *   提示：EA = (R1) + D
3.  **间接寻址 (一次间接)**：
    *   提示：EA = (D)

<br>
<br>
<br>
<hr>
<br>
<br>
<br>

### 架构师解析 (你掉坑里了吗？)

#### 第一题解析：相对寻址 (负数回跳)
**答案：1FE2H**

**解题逻辑**：
1.  **更新 PC (最重要的第一步)**：
    *   当前在 `2000H`，指令长 2 字节。
    *   取指刚结束，PC 自动加 2。
    *   **当前基准 PC = 2002H**。
2.  **解析偏移量 (补码陷阱)**：
    *   偏移量是 `E0H` (8位)。
    *   二进制：`1110 0000`。
    *   符号位是 1，说明是**负数** (往回跳)。
    *   **补码转真值**：
        *   取反：`0001 1111`
        *   加1： `0010 0000` -> 32
        *   所以 `E0H` 代表 **-32** (十进制) 或者 **-20H** (十六进制)。
3.  **计算 EA**：
    *   `EA = (PC) + Offset`
    *   `EA = 2002H - 20H = 1FE2H`。

> **防坑指南**：如果你算成 `20E2` 或者 `2000 - 20`，说明你忘了“PC先更新”或者忘了“补码负数”。

---

#### 第二题解析：基址 vs 变址
**答案**：
1.  访问数组 `i` -> 选 **IX (变址寄存器)**。
2.  OS 搬移程序 -> 改 **BR (基址寄存器)**。

**软件思维类比**：
*   **变址 (Index)**：就像 `for(int i=0...)` 里的 `i`。这是程序员控制的，用来在数据结构里“变”位置。指令里的 `Offset` 是数组固定的首地址（形式地址 D）。
    *   $EA = (IX) + D$。这里 IX 在变，D 不变。
*   **基址 (Base)**：就像你租房的“小区地址”。你在小区里住几号楼（程序内的偏移 D）是写死的。但是整个小区可能搬迁（重定位）。
    *   $EA = (BR) + D$。这里 BR (OS管的) 在变，D (程序写的) 不变。

---

#### 第三题解析：综合侦探
**答案**：
1.  **寄存器间接 (R1)** -> **0300H**
    *   逻辑：去 R1 (`0200H`) 指向的地址找。
    *   Mem[`0200H`] = `0300H`。

2.  **变址 (R1)** -> **0500H**
    *   逻辑：`EA = (R1) + D` = `0200H` + `0200H` = `0400H`。
    *   去 `0400H` 找数据。
    *   Mem[`0400H`] = `0500H`。

3.  **间接寻址** -> **0400H**
    *   逻辑：`EA = (D)`。
    *   D 是 `0200H`。去 `0200H` 找，发现里面存的是 `0300H` (这是个指针)。
    *   再去 `0300H` 找数据。
    *   Mem[`0300H`] = `0400H`。


---

# 第四章：总线与 I/O —— 计算机的“物流系统”

## 1. 总线 (The Bus)：计算机的高速公路

### 1.1 什么是总线？
**软件视角**：
只要你写过网络编程，你就知道“公共信道”的概念。
**硬件视角**：
CPU 只有一套手脚，但他要连内存、连硬盘、连显卡。如果每两个设备之间都拉一根线，计算机内部就变成盘丝洞了。
所以，大家共用一组电缆，这就是**总线**。

### 1.2 总线的三大车道 (必考)
总线不仅仅是一根线，它通常包含几十根线，分为三类功能：

1.  **数据总线 (Data Bus)**：**运货车道**。
    *   双向传输。
    *   **宽度**决定了 CPU 一次能吃多少饭（32位还是64位）。
2.  **地址总线 (Address Bus)**：**导航车道**。
    *   单向（CPU -> 设备）。
    *   **宽度**决定了 CPU 能找到多大的内存（32根线 = 4GB）。
3.  **控制总线 (Control Bus)**：**红绿灯/指挥车道**。
    *   传输读/写信号、中断请求等。

### 1.3 核心计算：总线带宽 (Bandwidth)
这是本章**唯一的数学题**，送分题。

**公式**：
$$带宽 (MB/s) = \frac{总线频率 (MHz) \times 总线宽度 (bit)}{8}$$
*(为什么要除以 8？因为要把 bit 换算成 Byte)*

**手把手演示**：
> 某总线工作频率 100MHz，数据总线宽度 32位。求带宽。
>
> 1.  **一次传输量**：32 bit / 8 = 4 Bytes。
> 2.  **每秒次数**：100 M (百万次)。
> 3.  **带宽** = $100 \times 4 = 400 \text{MB/s}$。

---

## 2. I/O 控制方式的演变 (The Evolution of Laziness)

这是本章的**灵魂**。
**场景设定**：CPU 是**公司 CEO**（时薪 100万），键盘/硬盘是**实习生**（时薪 10块）。
CEO 怎么从实习生手里拿数据？经历了三个阶段的进化。

### 阶段 1：程序查询方式 (Polling) —— 累死 CEO
*   **机制**：CPU 写个 `while(true)` 循环，不断询问键盘：“你被按下了吗？没有？那我等会儿再问。”
*   **缺点**：**CPU 全程踏步（Busy Waiting）**，什么别的活都干不了。
*   **软件类比**：前端里的“轮询接口”。
*   **地位**：早期计算机用，现在早淘汰了，除非是极其简单的单片机。

### 阶段 2：中断驱动方式 (Interrupt) —— CEO 的电话响了
*   **机制**：
    1.  CPU 专心算它的代码。
    2.  你按了一下键盘。
    3.  键盘给 CPU 发个信号（中断请求）。
    4.  CPU **暂停**手头工作，保存现场，去处理按键，处理完回来接着干。
*   **优点**：CPU 和设备**并行工作**。
*   **软件类比**：**回调函数 (Callback)**、Java 的 `try-catch` 异常处理、GUI 的事件监听。
*   **适用**：**鼠标、键盘**等低速、随机发生的事件。

### 阶段 3：DMA 方式 (Direct Memory Access) —— 请个搬运工
*   **痛点**：中断虽好，但如果是从硬盘读 1GB 电影？
    *   每读 1 个字就中断一次 CPU，CPU 光是用来“保存现场、恢复现场”就累吐血了。
*   **机制**：
    1.  CPU 对 **DMA 控制器**（搬运工）说：“把硬盘 A 地址的数据，搬 1GB 到内存 B 地址去。**搬完再告诉我**。”
    2.  CPU 转头去干别的。
    3.  DMA 也是个小芯片，专门负责搬数据。
    4.  搬完后，DMA 发**一个**中断告诉 CPU：“老板，活干完了”。
*   **优点**：CPU 彻底解放，只在开始和结束时参与。
*   **适用**：**硬盘、显卡、网卡**等高速、大数据量设备。

---

## 3. 深入理解：中断 (Interrupt) 的全过程

**408 必考逻辑题：** 中断发生时，硬件做了什么？软件做了什么？

请把这个过程想象成 **“在打游戏时老板突然来电话”**。

| 步骤 | 动作 | 谁做的？(Hardware vs Software) | 类比 |
| :--- | :--- | :--- | :--- |
| **1. 关中断** | 暂时屏蔽其他电话，防止干扰。 | **硬件 (自动)** | 捂住话筒，防止杂音。 |
| **2. 保存断点** | 把 **PC** (下一条指令地址) 和 **PSW** (状态字) 压入堆栈。 | **硬件 (自动)** | 记住游戏暂停在第几关。 |
| **3. 找入口** | 根据中断号，找到**中断服务程序**的地址 (中断向量)。 | **硬件 (自动)** | 看来电显示，知道是老板，翻电话本找老板的应对脚本。 |
| **4. 保存现场** | 把通用寄存器 (R0, R1...) 压栈。 | **软件 (OS代码)** | 把手里的可乐、薯片放好。 |
| **5. 执行服务** | 执行处理逻辑 (比如读取键盘输入)。 | **软件 (OS代码)** | 接电话：“好的老板，我马上改”。 |
| **6. 恢复现场** | 弹出通用寄存器。 | **软件 (OS代码)** | 拿回可乐、薯片。 |
| **7. 开中断** | 允许接新电话。 | **硬件/软件** | 松开话筒。 |
| **8. 返回** | 弹出 PC 和 PSW，回到断点。 | **硬件 (指令)** | 游戏取消暂停，继续打。 |

> **坑点警示**：
> 考试常问：**PC 是谁保存的？**
> 答案：**硬件**！因为还没跳转到软件处理程序之前，必须先锁住当前位置，否则就丢了。

---

## 4. 易混概念：中断 vs DMA

这是选择题最爱出的干扰项。

| 特性 | 中断 (Interrupt) | DMA (Direct Memory Access) |
| :--- | :--- | :--- |
| **主要目的** | 处理**随机事件** / 异常 | 批量**搬运数据** |
| **CPU 参与度** | 高 (每传输一个数据都要中断) | 低 (传输一块数据才中断一次) |
| **响应时机** | **指令执行结束后** (大部分情况) | **存取周期结束后** (随时插入) |
| **软件类比** | 鼠标点击事件 | 文件拷贝 |
| **打断谁？** | 打断 CPU 的**程序执行** | 打断 CPU 的**内存访问** (窃取总线周期) |

**最后一点最难理解，我解释一下（窃取周期）**：
DMA 在搬运数据时，并没有把 CPU“关掉”。它只是趁 CPU 在解码指令、算数的空档，**偷偷占用一下总线**去访问内存。CPU 甚至可能都没感觉。这就叫“周期窃取”。

---

## 5. 今日作业 (总线与 I/O)

**Q1. [计算题]**
某计算机总线频率 33MHz，总线宽度 32位。若该总线每传输一个数据都需要 2 个时钟周期（一个传地址，一个传数据）。
请计算该总线的实际数据传输率 (MB/s)。

**Q2. [概念辨析]**
(1) 鼠标滑动
(2) 键盘输入字符
(3) 内存不够了，从硬盘读取 4KB 页面到内存
以上三个场景，分别最适合使用哪种 I/O 控制方式？(中断 还是 DMA？)

<br>
<br>
<br>

**参考答案**：

**A1. 计算题**：
1.  宽度 32位 = 4 Bytes。
2.  本来每秒 33M 次时钟，但每 **2个** 周期才传一次数据。
3.  有效传输次数 = $33 / 2 = 16.5$ M次/秒。
4.  带宽 = $16.5 \times 4 = 66 \text{MB/s}$。
    *(这题的坑在于“2个周期传一次”)*

**A2. 概念题**：
1.  **鼠标滑动** -> **中断** (数据量极小，随机)。
2.  **键盘输入** -> **中断** (人手速很慢，数据量小)。
3.  **读硬盘页面** -> **DMA** (4KB 是成块的大数据，用中断会累死 CPU)。

---

# 第五章：中央处理器 (The CPU)

## 1. 拆解 CPU：只有两个部门

如果把 CPU 看作一个 **指挥部**，它只有两个核心部门：

| 部门 | 名称 | 英文 | 职责 | 软件类比 |
| :--- | :--- | :--- | :--- | :--- |
| **运算部** | **运算器** | ALU + 寄存器 | **干苦力的**。负责算数 (`+ - * /`) 和逻辑 (`AND OR`)。 | 具体的函数实现 `add(a,b)` |
| **指挥部** | **控制器** | CU (Control Unit) | **发号施令的**。它不干活，只告诉运算器“现在该加法了”、“现在该去读内存了”。 | `main` 函数里的调度逻辑 |

---

## 2. 核心寄存器：CPU 的“贴身口袋” (必背)

在数据通路大题中，你必须知道这些缩写代表什么，否则连题目都读不懂。

### 2.1 用户可见寄存器 (程序员能用的)
*   **PC (Program Counter)**：**程序计数器**。
    *   **作用**：永远指着**下一条**要执行的指令地址。
    *   **动作**：每取完一条指令，自动 +1 (或+指令长度)。
*   **ACC (Accumulator)**：**累加器**。
    *   **作用**：存运算结果的老式寄存器（现在的 x86 叫 EAX）。
*   **GPRs (General Purpose Registers)**：**通用寄存器** (R0, R1...)。
    *   **作用**：随便用，存临时变量。

### 2.2 用户不可见寄存器 (硬件偷偷用的)
*   **IR (Instruction Register)**：**指令寄存器**。
    *   **作用**：存放**当前正在执行**的那条指令。
    *   **流程**：指令从内存取出来 -> 放入 IR -> 拆解分析。
*   **MAR (Memory Address Register)**：**存储器地址寄存器**。
    *   **作用**：**内存的大门钥匙**。CPU 想去内存哪个房间，必须先把房号写在这里。
*   **MDR (Memory Data Register)**：**存储器数据寄存器**。
    *   **作用**：**内存的传达室**。从内存读出来的数据，或者要写进内存的数据，必须先暂存在这里。

> **必考数据通路逻辑**：
> CPU 要读内存：
> 1. 把地址写入 **MAR**。
> 2. 发出“读”信号。
> 3. 数据从内存流向 **MDR**。
> 4. CPU 从 MDR 取走数据。

---

## 3. 指令执行的微观流程 (The Heartbeat)

这是大题的基础。一条指令的生命周期（指令周期）通常分为四个阶段：

1.  **取指周期 (Fetch)**：
    *   `PC` -> `MAR` -> `内存` -> `MDR` -> `IR`
    *   *同时：PC = PC + 1*
2.  **间址周期 (Indirect)**：(如果有间接寻址)
    *   去内存把“地址的地址”取回来，换成真实地址。
3.  **执行周期 (Execute)**：
    *   真正干活（比如加法、跳转）。
4.  **中断周期 (Interrupt)**：
    *   查查有没有人打电话（中断请求），有就去处理。

---

## 4. 控制器的两种设计 (硬布线 vs 微程序)

这是选择题常客。
**问题**：谁来控制这些寄存器开门关门？谁发出“加法”信号？

### 4.1 硬布线控制器 (Hardwired)
*   **原理**：用很多很多**逻辑门电路** (与非门) 焊死在芯片上。
*   **特点**：**速度极快**，但电路极其复杂，修改极其困难（改设计=重新流片）。
*   **适用**：**RISC** 架构 (简单的指令，追求极致速度)。

### 4.2 微程序控制器 (Microprogrammed) —— **重点**
*   **原理**：**套娃**。
    *   CPU 内部还有一个小 CPU。
    *   每条汇编指令（如 `ADD`），对应一段**微程序 (Micro-program)**。
    *   微程序由若干条**微指令 (Micro-instruction)** 组成。
*   **存储**：这些微程序存在 CPU 内部的一个**只读存储器**里，叫 **控制存储器 (CM)**。
*   **特点**：速度稍慢，但设计简单，容易修改（刷固件）。
*   **适用**：**CISC** 架构 (复杂指令)。

> **核心概念辨析**：
> *   **主存 (Main Memory)**：存你的 Java/C 代码。
> *   **控存 (CM)**：存 CPU 的微指令（固件）。

---

## 5. 指令流水线 (Pipelining) —— **计算题得分王**

这是本章性价比最高的地方。

### 5.1 概念类比：洗衣服
假设洗衣服分 3 步：**洗涤(1h) -> 烘干(1h) -> 折叠(1h)**。
*   **串行方式**：洗完衣服1，再洗衣服2。洗 3 桶衣服要 **9小时**。
*   **流水线方式**：
    *   第 1 小时：衣服1 在洗涤。
    *   第 2 小时：衣服1 去烘干，**衣服2 放入洗涤**。
    *   第 3 小时：衣服1 折叠，衣服2 烘干，**衣服3 洗涤**。
    *   洗 3 桶衣服只要 **5小时**！

### 5.2 性能计算公式
假设一条指令分 $k$ 个阶段，每个阶段时间为 $\Delta t$。
执行 $n$ 条指令。

*   **传统耗时**：$n \times k \times \Delta t$
*   **流水线耗时**：$(k + n - 1) \times \Delta t$
    *   **理解**：第 1 条指令完整走完需要 $k$ 个时间，剩下的 $n-1$ 条指令，每一条只需要多 1 个时间单位就能蹦出来。
*   **吞吐率 (TP)**：指令数 / 总时间。

### 5.3 坑点：流水线冒险 (Hazards) —— 为什么流水线会卡住？

1.  **结构冒险 (Structural Hazard)**：**抢马桶**。
    *   原因：指令 A 要去取指（读内存），指令 B 要去取数（读内存）。只有一个内存接口，打架了。
    *   解决：把指令Cache和数据Cache分开（哈佛结构）。

2.  **数据冒险 (Data Hazard)**：**等米下锅**。
    *   代码：
        1. `ADD R1, R2, R3` (R1 = R2 + R3)
        2. `SUB R4, R1, R5` (R4 = **R1** - R5)
    *   原因：第 2 句要用 R1，但第 1 句还没算完写回去呢！
    *   解决：**数据旁路 (Forwarding)** —— 刚算出来还没存热乎，直接拉根线传给下一级。

3.  **控制冒险 (Control Hazard)**：**猜错了路**。
    *   原因：遇到 `if-else` 或 `JMP`。流水线已经把下面的指令读进来了，结果发现要跳转到别的地方。读进来的都白读了（Flush）。
    *   解决：**分支预测 (Branch Prediction)** —— 瞎猜（基于历史猜），猜对赚大发，猜错倒大霉。

---

## 6. 终极实战：数据通路的大题逻辑

考试会给你一张复杂的图，问你 `MOV (R1), R2` 这条指令在图上怎么走。

**解题口诀 (类似于写伪代码)**：

1.  **取指阶段**：
    `PC -> MAR -> Mem -> MDR -> IR`
    `PC + 1 -> PC`
2.  **取数阶段** (间接寻址 `(R1)` )：
    *   先把 R1 的值当作地址：`R1 -> MAR`
    *   读内存：`Mem -> MDR`
    *   现在 MDR 里就是目标地址了。
3.  **执行阶段** (写数)：
    *   把 R2 的数据送到 MDR：`R2 -> MDR`
    *   启动写信号：`Write Signal`

**核心技巧**：看着箭头写流程。数据必须经过总线，不能飞过去。

---

## 7. 今日作业 (CPU 毕业考)

**Q1. [流水线计算]**
某计算机指令流水线分 5 级：取指、译码、执行、访存、写回。
每级耗时分别为：`10ns, 10ns, 20ns, 10ns, 10ns`。
(注意：流水线的时钟周期必须适应**最慢**的那一级)
请问：
1.  流水线的时钟周期是多少？
2.  执行 100 条指令，大约需要多少时间？

**Q2. [概念理解]**
为了减少 **“控制冒险”** (Control Hazard) 带来的性能损失，现代 CPU 主要采用了什么技术？
A. 数据旁路
B. 分支预测
C. 增加 Cache
D. 提高主频

**Q3. [微程序]**
机器指令和微指令的关系是：
A. 1对1
B. 1对多
C. 多对1
D. 没关系

<br>
<br>
<br>

**参考答案**：

**A1.**
1.  **周期**：取决于最慢的一级，即执行阶段的 **20ns**。（就像木桶效应，流水线速度受限于最慢的工人）。
2.  **总时间**：
    *   公式：$(k + n - 1) \times \text{Cycle}$
    *   $k=5$ (5级), $n=100$
    *   $Time = (5 + 100 - 1) \times 20\text{ns}$
    *   $104 \times 20 = 2080\text{ns}$。
    *   *(注：如果用非流水线，就是 100 * (10+10+20+10+10) = 6000ns。快了3倍！)*

**A2.** **B (分支预测)**。
*   A 是解决数据冒险。
*   C 是解决速度匹配。

**A3.** **B (1对多)**。
*   一条汇编指令 (如 `ADD`) 需要很多步微操作 (取指、取数、加法、写回) 才能完成。

---